aspect LoopAnalysis {
	private boolean Expr.loopConditionStatus = false;

	public boolean Expr.isLoopCondition() {
		return this.loopConditionStatus;
	}

	public void Expr.setIsLoopCondition(boolean status) {
		this.loopConditionStatus = status;
	}

	private BranchTargetStmt Expr.conditionHostStmt;

	public void Expr.setHostStmt(BranchTargetStmt stmt) {
		this.conditionHostStmt = stmt;
	}

	public BranchTargetStmt Expr.getHostStmt() {
		return this.conditionHostStmt;
	}

	private HashMap<Variable, HashMap<String, State>> BranchTargetStmt.initialTable;

	public HashMap<Variable, HashMap<String, State>> BranchTargetStmt.getInitialTable() {
		return this.initialTable;
	}

	public void BranchTargetStmt.setInitialTable(HashMap<Variable, HashMap<String, State>> table) {
		this.initialTable = table;
	}

	public boolean BranchTargetStmt.isValidContinueState(HashMap<Variable, HashMap<String, State>> continueTable) {
		for (Variable v: continueTable.keySet()) {
			if (!this.initialTable.keySet().contains(v)) {
				return false;
			} else if (!initialTable.get(v).equals(continueTable.get(v))) {
				return false;
			}
		}
		return true;
	}

	public boolean BranchTargetStmt.isValidContinueStateByMethodAccess(HashMap<Variable, HashMap<String, State>> continueTable) {
		LinkedList<MethodAccess> methodAccessList = this.collectMethodAccess();
		for (Variable v: continueTable.keySet()) {
			for (MethodAccess ma: methodAccessList) {
				Expr va = ma.prevExpr();
				if (va.isVariable()) {
					if (v.equals(va.varDecl())) {
						State s = getSingleStateFromMap(continueTable.get(v));
						TypestateMethodList list = (TypestateMethodList) s.getTypestate();
						if (list.lookupMethod(ma.decl()) == null) {
							return false;
						} else {
							break;
						}
					}
				}
			}
		}
		return true;
	}

	/**
	 * Collect typestate MethodAccess in a BranchTargetStmt
	 */
	coll LinkedList<MethodAccess> BranchTargetStmt.collectMethodAccess() root BranchTargetStmt;
	ConstructorDecl contributes {
		if (checkImplicitConstructorInvocation()) {
			getImplicitConstructorInvocation().collectContributions();
		}
		super.collectContributions();
	} to BranchTargetStmt.collectMethodAccess();

	/**
	 * Report MethodAccess with typestate to BranchTargetStmt
	 */
	MethodAccess contributes each reportMethodAccess() to BranchTargetStmt.collectMethodAccess();
	syn Collection<MethodAccess> MethodAccess.reportMethodAccess() {
		LinkedList<MethodAccess> list = new LinkedList<MethodAccess>();
		if (hasTypestateDecl()) {
			list.add(this);
		}
		return list;
	}
}