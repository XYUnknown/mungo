/**
 * Typestate checking in each node of the AST
 * Every node contribute typestate problems to compilation unit problem collection
 */
aspect TypestateCheck {
    /**
     * Typestate checking in TypeDecl
     */
    TypeDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> TypeDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a TypeDecl could have at most one typestate annotation
            problems.add(error("A TypeDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        if(td != null){
            System.out.println("Found TypestateDecl in TypeDecl: " + td.getID());
        }        
        return problems;
    }

    /**
     * Typestate checking in ClassDecl
     * ClassDecl: TypeDecl
     */
    ClassDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a ClassDecl could have at most one typestate annotation
            problems.add(error("A ClassDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        if(td != null){
            System.out.println("Found TypestateDecl in ClassDecl: " + td.getID());
        }        
        return problems;
    }

    /**
     * MethodAccess: c.foo()
     * From a MethodAccess we could get VariableAccess and MethodDecl
     */
	MethodAccess contributes each typestateProblems() to CompilationUnit.problems();
  	syn Collection<Problem> MethodAccess.typestateProblems() {
  		LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("---------checking------------");
        System.out.println("MethodAccess name: " + name());
        System.out.println("MethodAccess preExpr: " + prevExpr() + " " + prevExpr().getClass());
        System.out.println("MethodAccess parentDot: " + parentDot() + " " + parentDot().getClass());  
        Expr va = prevExpr();
        if(va != null) { // avoid situation such as 1) implicit self reference 2) static method
            if (va.hasTypestateState() && !va.hasState()) { // if va does not have state, report error
                problems.add(error("No Init State found in VarAccess " + va));
                return problems;
            }
            if(va.hasTypestateState() && va.hasState()) {
                //ASTNode vd = (ASTNode) va.varDecl();  
                //TypestateMethod tsMethod = null; // used for lookup method with signature              
                MethodDecl md = this.decl();
                HashMap<String, State> stateMap = va.getState();
                if (stateMap.size() == 0){
                    // End of state error reporting
                    problems.add(error("Reach end of state " + va));
                    return problems;
                } else if (stateMap.size() == 1) { // No switch
                    // Typestate checking and state updating
                    State currState = getSingleStateFromMap(stateMap);                 
                    problems = collectProblems(currState, md, va);
                    if (problems.size() != 0) {
                        return problems;
                    }
                } else {
                    // Typestate switch handling                   
                    SwitchStmt switchStmt = lookupSwitch();
                    if (switchStmt == null) { // TypestateSwitch is not handled, report error.
                        problems.add(error("Invalid MethodAccess " + this + " in TypestateSwitch State"));
                        return problems;
                    } else {
                        HashMap<Stmt, StmtInfo> infoMap = switchStmt.getStmtInfoMap();
                        // Lookup information of the Stmt which contains this MethodAccess, if not found report error
                        StmtInfo info = this.lookupInfo(infoMap);
                        if (info == null) {
                            problems.add(error("MethodAccess " + this + " in SwitchStmt does not have valid case label."));
                            return problems;
                        }
                        // Lookup case label, if the TypestateSwitch does not contains the label, report error.
                        String caseLabel = info.getCaseLabel();                       
                        if (!stateMap.containsKey(caseLabel)) {
                            problems.add(error("TypestateSwitch does not contains key " + caseLabel));
                            return problems;
                        }
                        // Typestate checking and state updating
                        State currState = stateMap.get(caseLabel);
                        problems = collectProblems(currState, md, va);
                        if (problems.size() != 0) {
                            return problems;
                        }
                        // Reset state when encounter termination statement
                        if (info.hasTermination()) { 
                            va.setState(stateMap);
                        }
                    }
                }               
            }
        }
        // Checking null state argument for all method Access
        if (hasParamWithNullState()) {
            VarAccess arg = getParamWithNullState();
            problems.add(error("No Init State found in MethodAccess argument " + arg));
            return problems;
        }    
  		return problems;
	}

    /**
     * Declarator - C c;
     */
    Declarator contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Declarator.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>(); 
        if (hasTypestateState()) {
            if (!hasState()) { // getInit() : Expr
                if ((getInit() != null ) && !(getInit() instanceof NullLiteral)) { // taking care of C c = null; and C c;
                    System.out.println("Init: " + getInit().getClass() + " type: " + getInit().type()); 
                    if (getInit() instanceof ClassInstanceExpr) { // C c = new C();
                        ClassInstanceExpr ins = (ClassInstanceExpr) getInit();
                        setState(ins.getState());
                    } else if (getInit() instanceof VarAccess) { // C c1 = new C(); C c = c1;
                        VarAccess va = (VarAccess) getInit();
                        if (!va.hasTypestateState()) {
                            problems.add(error("Typestate mismatch, no typestate found in source variable access " + va));
                            return problems;
                        }
                        ASTNode d = (ASTNode) va.varDecl();
                        setState(va.getState());
                        d.setState(null); // one typestate object could only have one reference.
                    } else if (getInit() instanceof Dot) { // C c = a.get();
                        // TODO: checking return type?
                        Dot d = (Dot) getInit();
                        if (!d.hasTypestateState()) {
                            problems.add(error("Typestate mismatch, no typestate found in source dot " + d));
                            return problems;
                        }
                        setState(d.getState());
                    } else {
                        // TODO analysing other Expr
                    }
                    if (!hasState()) {
                        problems.add(error("No Init State of VariableDeclarator: " + this));
                    }
                }                
            }            
        }
        return problems;
    }

    /**
     * AssignExpr - c1 = c2;
     */
    AssignExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> AssignExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (!getDest().isVariable()) {
            problems.add(error("left hand side is not a variable"));
            return problems;
        }
        if ((getDest().hasTypestateState() ^ getSource().hasTypestateState()) && !(getSource() instanceof NullLiteral)) { // c = null
            problems.add(error("Typestate mismatch. src has typestate? " + getSource().hasTypestateState() 
                + " dest has typestate? " + getDest().hasTypestateState()));
            return problems;
        }
        if (getSource().hasTypestateState()) {  
            //State state = null;
            HashMap<String, State> state = null;
            if (getSource() instanceof VarAccess) { // c = c1
                VarAccess va = (VarAccess) getSource();
                ASTNode d = (ASTNode) va.varDecl();
                state = va.getState();
                d.setState(null); // one typestate object could only have one reference. 
            } else if (getSource() instanceof ClassInstanceExpr) {
                ClassInstanceExpr ins = (ClassInstanceExpr) getSource();
                state = ins.getState(); 
            } else if (getSource() instanceof Dot) { // c = c1.foo();
                // TODO: checking return type?
                Dot d = (Dot) getSource();
                if (!d.hasTypestateState()) {
                    problems.add(error("Typestate mismatch, no typestate found in source dot " + d));
                    return problems;
                }
                state = d.getState();
            } else {
                // TODO analysing other Expr
            }
            if (getDest() instanceof VarAccess) { 
                VarAccess dva = (VarAccess) getDest();
                ASTNode dest = (ASTNode)dva.varDecl();
                dest.setState(state);
            } else {
                problems.add(error("Cannot set state"));
            }
        }        
        return problems;
    }

    ClassInstanceExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassInstanceExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (this.hasTypestateState()) {
            if (!this.hasState()) {
                problems.add(error("ClassInstanceExpr has no Init state"));
                return problems;
            } else if (this.getState().size() > 1) {
                problems.add(error("ClassInstanceExpr should be in Init state instead of a TypestateSwitch"));
                return problems;
            } else { //if (!this.getState().equals(type().getTypestateDecl().getInitState())) {
                State state = getSingleStateFromMap(this.getState());
                if (!this.getState().containsKey(type().getTypestateDecl().getInitState().getID())) {
                    problems.add(error("ClassInstanceExpr should be in Init state instead of " + ((state != null) ? state.getID() : "null")));
                }                
            }
        }
        return problems;
    }

    MethodDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> MethodDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        Block block = getBlock();
        if (!(this.getTypeAccess() instanceof PrimitiveTypeAccess)) { // PrimitiveTypeAccess will not have TypestateDecl
            if (hasTypestateDecl() && returnHasTypestateDecl()) { // Both hostType and return type has TypestateDecl
                TypestateDecl td = this.hostType().getTypestateDecl();
                TypestateMethod tm = td.lookupMethod(this);
                if (tm == null) {
                    problems.add(error("Cannot find corresponding TypestateMethod in TypestateDecl"));
                    return problems;
                }
                if (block != null) { // Do not check return statement of abstract method declaration
                    for (Stmt s: block.getStmts()) { // All statements in MethodDecl block
                        if (s instanceof ReturnStmt) {
                            ReturnStmt rs = (ReturnStmt)s;
                            if (!tm.isSameReturnState(rs)) { // State mismatch, report error
                                problems.add(error("ReturnStmt Typestate mismatch"));
                            }
                        }
                    }
                }
            }            
        }         
        return problems;
    }

    /**
     * TODO Look up variables, check and update their states.
     *
     * switch (a.isFoo()) {...}
     *
     * Choice c = a.isFoo();
     * switch (c) {...}
     * 
     * In both cases, state of a need to be updated
     */
    SwitchStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> SwitchStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();      
        return problems;
    }

    LabeledStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> LabeledStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("LabeledStmt label: " + getLabel());
        return problems;
    }

    Case contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Case.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //this.doPrintFullTraversal();
        return problems;
    }

    /** Unused */
    ReturnStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ReturnStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("ReturnStmt class: " + returnType());
        //System.out.println("ReturnStmt result: " + getResult() + " " + getResult().getClass());
        return problems;
    }

    Dot contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Dot.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("varDecl of Dot: " + this + " " + this.varDecl());
        return problems;
    }

    VarAccess contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarAccess.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (hasTypestateDecl() && !hasState() ) {
            //problems.add(error("No Init State found in VarAccess " + this));
        }       
        return problems;
    }    

    VarDeclStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarDeclStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("VarDeclStmt: " + this + " " +this.lineNumber());
        //System.out.println("VarDeclStmt Declarators: ");
        for (VariableDeclarator vd: getDeclarators()){
            //System.out.println(vd);
        }
        return problems;
    }
}