/**
 * Typestate checking in each node of the AST
 * Every node contribute typestate problems to compilation unit problem collection
 */
aspect TypestateCheck {
    /**
     * Typestate checking in TypeDecl
     */
    TypeDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> TypeDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a TypeDecl could have at most one typestate annotation
            problems.add(error("A TypeDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        if(td != null){
            System.out.println("Found TypestateDecl in TypeDecl: " + td.getID());
        }        
        return problems;
    }

    /**
     * Typestate checking in ClassDecl
     * ClassDecl: TypeDecl
     */
    ClassDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a ClassDecl could have at most one typestate annotation
            problems.add(error("A ClassDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        if(td != null){
            System.out.println("Found TypestateDecl in ClassDecl: " + td.getID());
        }        
        return problems;
    }

    /**
     * MethodAccess: c.foo()
     * From a MethodAccess we could get VariableAccess and MethodDecl
     */
	MethodAccess contributes each typestateProblems() to CompilationUnit.problems();
  	syn Collection<Problem> MethodAccess.typestateProblems() {
  		LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("---------checking------------");
        System.out.println("MethodAccess name: " + name());
        System.out.println("MethodAccess instance: " + getVarAccess());
        VarAccess va = getVarAccess();
        if(va != null) { // avoid situation such as 1) implicit self reference 2) static method
            if(va.hasTypestateDecl() && va.hasState()) { // if va does not have state, VarAccess will report error               
                Declarator vd = (Declarator)va.varDecl();                
                MethodDecl md = this.decl();
                boolean result = false; // result of comparasion of method signatures
                TypestateLabel tl = null;
                TypestateMethodList typestate = (TypestateMethodList) va.getState().getTypestate();
                for (TypestateMethod tm: typestate.getTypestateMethodList()) {
                    result = md.isSameSignature(tm);
                    System.out.println("Same signature? " + result);                    
                    if (result) {
                        if (tm.getTypestate() instanceof TypestateLabel) {
                            tl = (TypestateLabel) tm.getTypestate();
                            vd.setState(tl.getTarget()); // Update State of VariableDeclarator
                        } else if (tm.getTypestate() instanceof TypestateSwitch){
                        // TODO: type state check of TypestateSwitch
                        }
                        break;
                    }
                }
                if(!result) {
                    problems.add(error("Invalid MethodAccess " + this + " in State: " + vd.getState().getID()));
                }
            }
        }        
  		return problems;
	}

    /**
     * Declarator - C c;
     */
    Declarator contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Declarator.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("Printing VD: " + this);  
        if (hasTypestateDecl()) {
            if (!hasState()) {
                if (!(getInit() instanceof NullLiteral)) { // taking care of C c = null 
                    System.out.println("Init: " + getInit().getClass() + " type: " + getInit().type()); 
                    if (getInit() instanceof ClassInstanceExpr) { // C c = new C();
                        setState(getTypestateInitState());
                    } else if (getInit() instanceof VarAccess) { // C c1 = new C(); C c = c1;
                        VarAccess va = (VarAccess) getInit();
                        setState(va.getState());
                    } else if (getInit().varDecl() instanceof Declarator) { // C c = a.get();
                        Declarator d = (Declarator) getInit().varDecl();
                        setState(d.getState());
                    } else {
                        // TODO: other case? 
                    }
                    if (!hasState()) {
                        problems.add(error("No Init State of VariableDeclarator: " + this));
                    }
                }                
            }            
        }
        return problems;
    }


    /**
     * AssignExpr - c1 = c2;
     */
    AssignExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> AssignExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("AssignExpr source: " + getSource().isVariable() + " " + getSource().getClass());
        //System.out.println("AssignExpr dest: " + getDest().isVariable() + " " + getDest().getClass() + " " + getDest().varDecl().getClass());
        if (!getDest().isVariable()) {
            problems.add(error("left hand side is not a variable"));
            return problems;
        }
        if (getSource().isVariable()) {            
            if (getDest().hasTypestateDecl() ^ getSource().hasTypestateDecl()) {
                problems.add(error("Typestate mismatch. src has typestate? " + getSource().hasTypestateDecl() 
                    + " dest has typestate? " + getDest().hasTypestateDecl()));
                return problems;
            } else if (getSource().hasTypestateDecl()) {  
                State state = null;
                if (getSource() instanceof VarAccess) { // c = c1
                    VarAccess va = (VarAccess) getSource();
                    state = va.getState();
                } else if (getSource().varDecl() instanceof Declarator) { // c = c1.foo();
                    Declarator d = (Declarator) getSource().varDecl();
                    state = d.getState();
                } else {
                    // TODO other cases?
                }
                System.out.println("State: " + state);
                if (getDest() instanceof VarAccess) { 
                    VarAccess dva = (VarAccess) getDest();
                    Declarator dest = (Declarator)dva.varDecl();
                    dest.setState(state);
                    System.out.println("Dest State: " + dva.getState());
                } else {
                    problems.add(error("Cannot set state"));
                }

            }
        }
        return problems;
    }

    VarAccess contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarAccess.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (hasTypestateDecl() && !hasState() ) {
            problems.add(error("No Init State found in VarAccess " + this));
        }       
        return problems;
    }

    /** Unused */
    ClassInstanceExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassInstanceExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        return problems;
    }

    VarDeclStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarDeclStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("VarDeclStmt: " + this + " " +this.lineNumber());
        //System.out.println("VarDeclStmt Declarators: ");
        for (VariableDeclarator vd: getDeclarators()){
            System.out.println(vd);
        }
        return problems;
    }

    


}