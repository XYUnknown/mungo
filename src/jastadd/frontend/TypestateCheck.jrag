/**
 * Typestate checking in each node of the AST
 * Every node contribute typestate problems to compilation unit problem collection
 */
aspect TypestateCheck {
    /**
     * Typestate checking in TypeDecl
     */
    TypeDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> TypeDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a TypeDecl could have at most one typestate annotation
            problems.add(error("A TypeDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        if(td != null){
            System.out.println("Found TypestateDecl in TypeDecl: " + td.getID());
        }        
        return problems;
    }

    /**
     * Typestate checking in ClassDecl
     * ClassDecl: TypeDecl
     */
    ClassDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a ClassDecl could have at most one typestate annotation
            problems.add(error("A ClassDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        if(td != null){
            System.out.println("Found TypestateDecl in ClassDecl: " + td.getID());
        }        
        return problems;
    }

    /**
     * MethodAccess: c.foo()
     * From a MethodAccess we could get VariableAccess and MethodDecl
     */
	MethodAccess contributes each typestateProblems() to CompilationUnit.problems();
  	syn Collection<Problem> MethodAccess.typestateProblems() {
  		LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("---------checking------------");
        System.out.println("MethodAccess name: " + name());
        System.out.println("MethodAccess instance: " + getVarAccess());
        VarAccess va = getVarAccess();
        if(va != null) { // avoid situation such as 1) implicit self reference 2) static method
            System.out.println("MethodAccess VA varDecl: " + va.varDecl() + " " + va.varDecl().getClass());
            if (va.hasTypestateState() && !va.hasState()) { // if va does not have state, report error
                problems.add(error("No Init State found in VarAccess " + va));
                return problems;
            }
            if(va.hasTypestateState() && va.hasState()) {               
                // Declarator vd = (Declarator)va.varDecl();
                ASTNode vd = (ASTNode) va.varDecl();  
                System.out.println("VD class cast " + vd.getClass());              
                MethodDecl md = this.decl();
                boolean result = false; // result of comparasion of method signatures
                TypestateLabel tl = null;
                TypestateMethodList typestate = (TypestateMethodList) va.getState().getTypestate();
                for (TypestateMethod tm: typestate.getTypestateMethodList()) {
                    result = md.isSameSignature(tm);
                    System.out.println("Same signature? " + result);                    
                    if (result) {
                        if (tm.getTypestate() instanceof TypestateLabel) {
                            tl = (TypestateLabel) tm.getTypestate();
                            vd.setState(tl.getTarget()); // Update State of VariableDeclarator
                        } else if (tm.getTypestate() instanceof TypestateSwitch){
                        // TODO: type state check of TypestateSwitch
                        }
                        break;
                    }
                }
                if(!result) {
                    problems.add(error("Invalid MethodAccess " + this + " in State: " + vd.getState().getID()));
                    return problems;
                }
            }
            
        } 
        // Checking argument
        for (int i = 0; i < getNumArg(); i++) {
            System.out.println("MethodAccess Param: " + getArg(i) + " " + getArg(i).getClass());
            if (getArg(i) instanceof VarAccess) {
                VarAccess arg = (VarAccess) getArg(i);
                if (arg.hasTypestateState() && arg.getState() == null) {
                   problems.add(error("No Init State found in argument " + arg));
                   return problems; 
                }
            }
        }     
  		return problems;
	}

    /**
     * Declarator - C c;
     */
    Declarator contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Declarator.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("Printing VD: " + this);  
        if (hasTypestateDecl()) {
            if (!hasState()) { // getInit() : Expr
                if (!(getInit() instanceof NullLiteral)) { // taking care of C c = null 
                    System.out.println("Init: " + getInit().getClass() + " type: " + getInit().type()); 
                    if (getInit() instanceof ClassInstanceExpr) { // C c = new C();
                        ClassInstanceExpr ins = (ClassInstanceExpr) getInit();
                        setState(ins.getState());
                    } else if (getInit() instanceof VarAccess) { // C c1 = new C(); C c = c1;
                        VarAccess va = (VarAccess) getInit();
                        Declarator d = (Declarator) va.varDecl();
                        setState(va.getState());
                        d.setState(null); // one typestate object could only have one reference.
                    } else if (getInit() instanceof Dot) { // C c = a.get();
                        // TODO: checking return type?
                    } else {
                        // TODO analysing other Expr
                    }
                    if (!hasState()) {
                        problems.add(error("No Init State of VariableDeclarator: " + this));
                    }
                }                
            }            
        }
        return problems;
    }

    /**
     * AssignExpr - c1 = c2;
     */
    AssignExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> AssignExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("AssignExpr source: " + getSource().isVariable() + " " + getSource().getClass());
        //System.out.println("AssignExpr dest: " + getDest().isVariable() + " " + getDest().getClass() + " " + getDest().varDecl().getClass());
        if (!getDest().isVariable()) {
            problems.add(error("left hand side is not a variable"));
            return problems;
        }
        if (getDest().hasTypestateDecl() ^ getSource().hasTypestateDecl()) {
            problems.add(error("Typestate mismatch. src has typestate? " + getSource().hasTypestateDecl() 
                + " dest has typestate? " + getDest().hasTypestateDecl()));
            return problems;
        }
        if (getSource().hasTypestateDecl()) {  
            State state = null;
            if (getSource() instanceof VarAccess) { // c = c1
                VarAccess va = (VarAccess) getSource();
                Declarator d = (Declarator) va.varDecl();
                state = va.getState();
                d.setState(null); // one typestate object could only have one reference. 
            } else if (getSource() instanceof ClassInstanceExpr) {
                ClassInstanceExpr ins = (ClassInstanceExpr) getSource();
                state = ins.getState(); 
            } else if (getSource() instanceof Dot) { // c = c1.foo();
                //Declarator d = (Declarator) getSource().varDecl();
                //state = d.getState();
            } else {
                // TODO analysing other Expr
            }
            System.out.println("State: " + state.getID());
            if (getDest() instanceof VarAccess) { 
                VarAccess dva = (VarAccess) getDest();
                Declarator dest = (Declarator)dva.varDecl();
                dest.setState(state);
                System.out.println("Dest State: " + dva.getState().getID());
            } else {
                problems.add(error("Cannot set state"));
            }
        }        
        return problems;
    }

    ClassInstanceExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassInstanceExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (this.hasTypestateState()) {
            if (!this.hasState()) {
                problems.add(error("ClassInstanceExpr has no Init state"));
            } else if (!this.getState().equals(type().getTypestateDecl().getInitState())) {
                problems.add(error("ClassInstanceExpr should be in Init state instead of " + this.getState().getID()));
            }
        }
        return problems;
    }

    /** Unused */
    Dot contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Dot.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("varDecl of Dot: " + this + " " + this.varDecl());
        return problems;
    }

    VarAccess contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarAccess.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (hasTypestateDecl() && !hasState() ) {
            //problems.add(error("No Init State found in VarAccess " + this));
        }       
        return problems;
    }    

    VarDeclStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarDeclStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("VarDeclStmt: " + this + " " +this.lineNumber());
        //System.out.println("VarDeclStmt Declarators: ");
        for (VariableDeclarator vd: getDeclarators()){
            //System.out.println(vd);
        }
        return problems;
    }
}