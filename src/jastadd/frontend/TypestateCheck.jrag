/**
 * Typestate checking in each node of the AST
 * Every node contribute typestate problems to compilation unit problem collection
 */
aspect TypestateCheck {
    /**
     * Typestate checking in TypeDecl
     */
    TypeDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> TypeDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a TypeDecl could have at most one typestate annotation
            problems.add(error("A TypeDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        if(td != null){
            System.out.println("Found TypestateDecl in TypeDecl: " + td.getID());
        }        
        return problems;
    }

    /**
     * Typestate checking in ClassDecl
     * ClassDecl: TypeDecl
     */
    ClassDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a ClassDecl could have at most one typestate annotation
            problems.add(error("A ClassDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        if(td != null){
            System.out.println("Found TypestateDecl in ClassDecl: " + td.getID());
        }        
        return problems;
    }

    /**
     * MethodAccess: c.foo()
     * From a MethodAccess we could get VariableAccess and MethodDecl
     */
	MethodAccess contributes each typestateProblems() to CompilationUnit.problems();
  	syn Collection<Problem> MethodAccess.typestateProblems() {
  		LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("---------checking------------");
        System.out.println("MethodAccess name: " + name());
        // System.out.println("MethodAccess instance: " + getVarAccess());
        // VarAccess va = getVarAccess();
        Expr va = prevExpr();
        System.out.println("MethodAccess preExpr: " + prevExpr() + " " + prevExpr().getClass());
        System.out.println("MethodAccess parentDot: " + parentDot() + " " + parentDot().getClass());        
        if(va != null) { // avoid situation such as 1) implicit self reference 2) static method
            if (va.hasTypestateState() && !va.hasState()) { // if va does not have state, report error
                problems.add(error("No Init State found in VarAccess " + va));
                return problems;
            }
            if(va.hasTypestateState() && va.hasState()) {
                //ASTNode vd = (ASTNode) va.varDecl();  
                TypestateMethod tsMethod = null; // used for lookup method with signature              
                MethodDecl md = this.decl();
                HashMap<String, State> stateMap = va.getState();
                if (stateMap.size() == 0){
                    problems.add(error("No State found in VarAccess " + va));
                    return problems;
                } else if (stateMap.size() == 1) { // No switch                  
                    State currState = getSingleStateFromMap(stateMap);
                    TypestateMethodList methodList = (TypestateMethodList) currState.getTypestate();
                    // lookup the TypestateMethod which has same signature as the MethodDecl
                    tsMethod = methodList.lookupMethod(md); 
                    if (tsMethod != null) { // The TypestateMethod is found
                        if(!isValidParamState(tsMethod)) {
                            problems.add(error("MethodAccess " + this + " has arguments in invalid state."));
                            return problems;
                        }
                        if (tsMethod.getTypestate() instanceof TypestateLabel) {
                            /**
                             * Update state - Store label and State in the state map
                             * label is the same as the State name
                             */
                            TypestateLabel tl = (TypestateLabel) tsMethod.getTypestate();
                            HashMap<String, State> newState = new HashMap<String, State>();
                            newState.put(tl.getTarget().getID(), tl.getTarget());
                            va.setState(newState); // Update State of VariableDeclarator
                        } else if (tsMethod.getTypestate() instanceof TypestateSwitch){
                            /**
                             * Update state - Store label and State in the state map
                             * lable is different from the State name
                             * For example TRUE: Empty
                             */
                            HashMap<String, State> newState = new HashMap<String, State>();
                            TypestateSwitch tsw = (TypestateSwitch) tsMethod.getTypestate();
                            for(TypestateSwitchCase c: tsw.getTypestateSwitchCases()) {
                                if (!(c.getTypestate() instanceof TypestateLabel)) {
                                    problems.add(error("TypestateSwitchCase should not have TypestateSwitch as target state."));
                                    return problems;
                                }
                                String label = c.getLabel();
                                State state = ((TypestateLabel) c.getTypestate()).getTarget();
                                newState.put(label, state);
                            }
                            va.setState(newState);
                        }   
                    } else { // The TypestateMethod is not found 
                        problems.add(error("Invalid MethodAccess " + this + " in State: " + currState.getID()));
                        return problems;
                    }
                } else {
                    // Typestate switch handling, might not be checked here
                    // TypestateSwitch is not handled, report error.
                    System.out.println(va.getState());
                    problems.add(error("Invalid MethodAccess " + this + " in TypestateSwitch State"));
                    return problems;
                }               
            }
        }
        // Checking null state argument for all method Access
        if (hasParamWithNullState()) {
            VarAccess arg = getParamWithNullState();
            problems.add(error("No Init State found in MethodAccess argument " + arg));
            return problems;
        }    
  		return problems;
	}

    /**
     * Declarator - C c;
     */
    Declarator contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Declarator.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("Printing VD: " + this);  
        if (hasTypestateState()) {
            if (!hasState()) { // getInit() : Expr
                if ((getInit() != null ) && !(getInit() instanceof NullLiteral)) { // taking care of C c = null; and C c;
                    System.out.println("Init: " + getInit().getClass() + " type: " + getInit().type()); 
                    if (getInit() instanceof ClassInstanceExpr) { // C c = new C();
                        ClassInstanceExpr ins = (ClassInstanceExpr) getInit();
                        setState(ins.getState());
                    } else if (getInit() instanceof VarAccess) { // C c1 = new C(); C c = c1;
                        VarAccess va = (VarAccess) getInit();
                        if (!va.hasTypestateState()) {
                            problems.add(error("Typestate mismatch, no typestate found in source variable access " + va));
                            return problems;
                        }
                        ASTNode d = (ASTNode) va.varDecl();
                        setState(va.getState());
                        d.setState(null); // one typestate object could only have one reference.
                    } else if (getInit() instanceof Dot) { // C c = a.get();
                        // TODO: checking return type?
                        Dot d = (Dot) getInit();
                        if (!d.hasTypestateState()) {
                            problems.add(error("Typestate mismatch, no typestate found in source dot " + d));
                            return problems;
                        }
                        setState(d.getState());
                    } else {
                        // TODO analysing other Expr
                    }
                    if (!hasState()) {
                        problems.add(error("No Init State of VariableDeclarator: " + this));
                    }
                }                
            }            
        }
        return problems;
    }

    /**
     * AssignExpr - c1 = c2;
     */
    AssignExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> AssignExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (!getDest().isVariable()) {
            problems.add(error("left hand side is not a variable"));
            return problems;
        }
        if ((getDest().hasTypestateState() ^ getSource().hasTypestateState()) && !(getSource() instanceof NullLiteral)) { // c = null
            problems.add(error("Typestate mismatch. src has typestate? " + getSource().hasTypestateState() 
                + " dest has typestate? " + getDest().hasTypestateState()));
            return problems;
        }
        if (getSource().hasTypestateState()) {  
            //State state = null;
            HashMap<String, State> state = null;
            if (getSource() instanceof VarAccess) { // c = c1
                VarAccess va = (VarAccess) getSource();
                ASTNode d = (ASTNode) va.varDecl();
                state = va.getState();
                d.setState(null); // one typestate object could only have one reference. 
            } else if (getSource() instanceof ClassInstanceExpr) {
                ClassInstanceExpr ins = (ClassInstanceExpr) getSource();
                state = ins.getState(); 
            } else if (getSource() instanceof Dot) { // c = c1.foo();
                // TODO: checking return type?
                Dot d = (Dot) getSource();
                if (!d.hasTypestateState()) {
                    problems.add(error("Typestate mismatch, no typestate found in source dot " + d));
                    return problems;
                }
                state = d.getState();
            } else {
                // TODO analysing other Expr
            }
            if (getDest() instanceof VarAccess) { 
                VarAccess dva = (VarAccess) getDest();
                ASTNode dest = (ASTNode)dva.varDecl();
                dest.setState(state);
            } else {
                problems.add(error("Cannot set state"));
            }
        }        
        return problems;
    }

    ClassInstanceExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassInstanceExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (this.hasTypestateState()) {
            if (!this.hasState()) {
                problems.add(error("ClassInstanceExpr has no Init state"));
                return problems;
            } else if (this.getState().size() > 1) {
                problems.add(error("ClassInstanceExpr should be in Init state instead of a TypestateSwitch"));
                return problems;
            } else { //if (!this.getState().equals(type().getTypestateDecl().getInitState())) {
                State state = getSingleStateFromMap(this.getState());
                if (!this.getState().containsKey(type().getTypestateDecl().getInitState().getID())) {
                    problems.add(error("ClassInstanceExpr should be in Init state instead of " + ((state != null) ? state.getID() : "null")));
                }                
            }
        }
        return problems;
    }

    MethodDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> MethodDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        Block block = getBlock();
        System.out.println("MethodDecl getAccess: " + this.getTypeAccess() + " " + this.getTypeAccess().getClass());
        if (!(this.getTypeAccess() instanceof PrimitiveTypeAccess)) { // PrimitiveTypeAccess will not have TypestateDecl
            if (hasTypestateDecl() && returnHasTypestateDecl()) { // Both hostType and return type has TypestateDecl
                TypestateDecl td = this.hostType().getTypestateDecl();
                TypestateMethod tm = td.lookupMethod(this);
                if (tm == null) {
                    problems.add(error("Cannot find corresponding TypestateMethod in TypestateDecl"));
                    return problems;
                }
                System.out.println("MethodDecl found TypestateMethod: " + tm);
                if (block != null) { // Do not check return statement of abstract method declaration
                    System.out.println("MethodDecl " + this.name() + " stmts: ");
                    for (Stmt s: block.getStmts()) { // All statements in MethodDecl block
                        if (s instanceof ReturnStmt) {
                            ReturnStmt rs = (ReturnStmt)s;
                            System.out.println("Same return state? " + tm.isSameReturnState(rs));
                            if (!tm.isSameReturnState(rs)) { // State mismatch, report error
                                problems.add(error("ReturnStmt Typestate mismatch"));
                            }
                        }
                    }
                }
            }            
        }         
        return problems;
    }

    /**
     * TODO Look up variables, check and update their states.
     *
     * switch (a.isFoo()) {...}
     *
     * Choice c = a.isFoo();
     * switch (c) {...}
     * 
     * In both cases, state of a need to be updated
     */
    SwitchStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> SwitchStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        Expr exp = getExpr();
        Block blk = getBlock();
        System.out.println("SwitchStmt Expr: " + exp + " State: " + exp.getTargetState());
        return problems;
    }

    LabeledStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> LabeledStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("LabeledStmt label: " + getLabel());
        return problems;
    }

    /** Unused */
    ReturnStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ReturnStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("ReturnStmt class: " + returnType());
        //System.out.println("ReturnStmt result: " + getResult() + " " + getResult().getClass());
        return problems;
    }

    Dot contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Dot.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("varDecl of Dot: " + this + " " + this.varDecl());
        return problems;
    }

    VarAccess contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarAccess.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (hasTypestateDecl() && !hasState() ) {
            //problems.add(error("No Init State found in VarAccess " + this));
        }       
        return problems;
    }    

    VarDeclStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarDeclStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("VarDeclStmt: " + this + " " +this.lineNumber());
        //System.out.println("VarDeclStmt Declarators: ");
        for (VariableDeclarator vd: getDeclarators()){
            //System.out.println(vd);
        }
        return problems;
    }
}