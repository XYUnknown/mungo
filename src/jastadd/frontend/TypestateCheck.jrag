/**
 * Typestate checking in each node of the AST
 * Every node contribute typestate problems to compilation unit problem collection
 */
aspect TypestateCheck {
    /**
     * Typestate checking in TypeDecl
     */
    TypeDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> TypeDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a TypeDecl could have at most one typestate annotation
            problems.add(error("A TypeDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }   
        return problems;
    }

    /**
     * Typestate checking in ClassDecl
     * ClassDecl: TypeDecl
     */
    ClassDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a ClassDecl could have at most one typestate annotation
            problems.add(error("A ClassDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        LinkedList<HashMap<Variable, HashMap<String, State>>> globalSymbolList = this.collectGlobals();
        this.addAllGlobals(globalSymbolList); 
        System.out.println("Global symbol table size: " + this.getSymbolTable().getGlobals().size());    
        return problems;
    }

    /**
     * MethodAccess: c.foo()
     * From a MethodAccess we could get VariableAccess and MethodDecl
     */
	MethodAccess contributes each typestateProblems() to CompilationUnit.problems();
  	syn Collection<Problem> MethodAccess.typestateProblems() {
  		LinkedList<Problem> problems = new LinkedList<Problem>();

        //-------printing for debug-------//
        System.out.println("---------checking------------");
        System.out.println("MethodAccess name: " + name() + " /hostType: " + this.hostType() + " /Type: " + this.type() + " /decl hostType: " + decl().hostType()); 
        if (((ClassDecl)hostType()).getSymbolTable()!= null){ 
            System.out.println("SymbolTable info: globals size " + 
            ((ClassDecl)hostType()).getSymbolTable().getGlobals().size() + " locals size: " + 
            ((ClassDecl)hostType()).getSymbolTable().getLocals().size() + " current local size: " +
            ((((ClassDecl)hostType()).getSymbolTable().getLocals().size() == 0) ? 0 : ((ClassDecl)hostType()).getSymbolTable().currentLocal().size()));
        }
        //-------end-------//

        if(hasPrevExpr()) { // avoid situation such as 1) implicit self reference 2) static method
            System.out.println("MethodAccess preExpr: " + prevExpr() + " " + prevExpr().getClass());
            Expr va = prevExpr();
            if (va.hasTypestateState() && !va.hasState()) { // if va does not have state, report error
                problems.add(error("No Init State found in VarAccess " + va));
                return problems;
            }
            if(va.hasTypestateState() && va.hasState()) {
                //ASTNode vd = (ASTNode) va.varDecl();  
                //TypestateMethod tsMethod = null; // used for lookup method with signature              
                MethodDecl md = this.decl();
                HashMap<String, State> stateMap = va.getState();
                if (stateMap.size() == 0){
                    // End of state error reporting
                    problems.add(error("Reach end of state " + va));
                    return problems;
                } else if (stateMap.size() == 1) { // No switch
                    // Typestate checking and state updating
                    State currState = getSingleStateFromMap(stateMap);                 
                    problems = collectProblems(currState, md, va);
                    if (problems.size() != 0) {
                        return problems;
                    }
                    System.out.println(this + " isSwitchStmtExpr? " + this.isSwitchStmtExpr());
                    if (this.isSwitchStmtExpr()) {
                        SwitchStmt hostSwitch = this.lookupExprSwitchStmt();
                        // init all the records and maps here
                        if (this.getTargetState() == null) {
                            problems.add(error("MethodAccess " + this + " with null target state should not be the Expr of SwitchStmt."));
                            return problems;
                        } else if (this.getTargetState().size() < 2) {
                            problems.add(error("MethodAccess " + this + " without a target TypestateSwitch should not be the Expr of SwitchStmt."));
                            return problems;
                        } else {
                            hostSwitch.setRecordTypestateSwitch(this.getTargetState());
                            hostSwitch.initStateMap();
                            hostSwitch.getStmtInfoMap();
                            hostSwitch.addVariable(hostSwitch.getRecordVariable());
                        }
                    }
                } else {
                    // Typestate switch handling
                    if (this.isSwitchStmtExpr()) {
                        problems.add(error("MethodAccess " + this + " in TypestateSwitch should not be the Expr of SwitchStmt"));
                        return problems;
                    }               
                    SwitchStmt hostSwitchStmt = lookupSwitch();
                    if (hostSwitchStmt == null) { // TypestateSwitch is not handled, report error. Ensured va is Variable here
                        problems.add(error("Invalid MethodAccess " + this + " in TypestateSwitch State"));
                        return problems;
                    } else {
                        // Load all parent switchstmt
                        LinkedList<SwitchStmt> switchStmtList = this.lookupAllSwitch();

                        HashMap<Stmt, StmtInfo> infoMap = hostSwitchStmt.getStmtInfoMap();
                        // Lookup information of the Stmt which contains this MethodAccess, if not found report error
                        StmtInfo info = this.lookupInfo(infoMap);
                        if (info == null) {
                            for (SwitchStmt stmt: switchStmtList) {
                                if (this.equals(stmt.getLastMethodAccess())) {
                                    // check end case equal
                                    System.out.println("Check end: " + stmt.isEndCaseSameState());
                                    if (!stmt.isEndCaseSameState()) {
                                        problems.add(error("End of case state not match"));
                                    }
                                }
                            }
                            problems.add(error("MethodAccess " + this + " in SwitchStmt does not have valid case label."));
                            return problems;
                        }
                        
                        // Lookup case label, if the TypestateSwitch does not contains the label, report error.
                        String caseLabel = info.getCaseLabel();                       
                        if (!stateMap.containsKey(caseLabel)) {
                            for (SwitchStmt stmt: switchStmtList) {
                                if (this.equals(stmt.getLastMethodAccess())) {
                                    // check end case equal
                                    System.out.println("Check end: " + stmt.isEndCaseSameState());
                                    if (!stmt.isEndCaseSameState()) {
                                        problems.add(error("End of case state not match"));
                                    }
                                }
                            }
                            problems.add(error("TypestateSwitch does not contains label " + caseLabel));
                            return problems;
                        }
                        // Reset state when encounter termination statement
                        if (!info.hasTermination()) {
                            for (SwitchStmt stmt: switchStmtList) {
                                if (this.equals(stmt.getLastMethodAccess())) {
                                    // check end case equal
                                    System.out.println("Check end: " + stmt.isEndCaseSameState());
                                    if (!stmt.isEndCaseSameState()) {
                                        problems.add(error("End of case state not match"));
                                    }
                                }
                            } 
                            problems.add(error(this + " is in an case without break or continue."));
                            return problems;
                        }

                        System.out.println("SwitchStmt record checking...");
                        System.out.println("SwitchStmt recordTypestateSwitch: " + hostSwitchStmt.getRecordTypestateSwitch());
                        System.out.println("SwitchStmt stateMap: " + hostSwitchStmt.getStateMap());
                        System.out.println("SwitchStmt infoMap: " + hostSwitchStmt.getStmtInfoMap().size());
                        
                        System.out.println("switchStmtList size : " + switchStmtList.size());

                        // Typestate checking and state updating
                        State currState;
                        if (hostSwitchStmt.getRecordCaseLabel() == null) {
                            hostSwitchStmt.setRecordCaseLabel(caseLabel);
                            currState = stateMap.get(caseLabel);
                        } else {
                            if (hostSwitchStmt.getRecordCaseLabel().equals(caseLabel)) {
                                // in same case, restore previous state for typestate checking
                                Variable v = hostSwitchStmt.getRecordVariable();
                                HashMap<String, HashMap<Variable, HashMap<String, State>>> hostStateMap = hostSwitchStmt.getStateMap();
                                HashMap<String, State> recordStateMap = hostStateMap.get(caseLabel).get(v);
                                currState = getSingleStateFromMap(recordStateMap);
                                //currState = getSingleStateFromMap(hostSwitchStmt.getRecordState()); // if in switch?
                            } else {
                                // host case label change
                                hostSwitchStmt.setRecordCaseLabel(caseLabel);
                                currState = stateMap.get(caseLabel);
                            }
                        }
                        // Typestate checking and state updating
                        problems = collectProblems(currState, md, va);                  
                        if (problems.size() != 0) {
                            for (SwitchStmt stmt: switchStmtList) {
                                if (this.equals(stmt.getLastMethodAccess())) {
                                    // check end case equal
                                    System.out.println("Check end: " + stmt.isEndCaseSameState());
                                    if (!stmt.isEndCaseSameState()) {
                                        problems.add(error("End of case state not match"));
                                    }
                                }
                            }
                            return problems;
                        }
                        // Reset and record state
                        //hostSwitchStmt.setRecordState(va.getState()); // record current state
                        Variable v = hostSwitchStmt.getRecordVariable();
                        for (SwitchStmt stmt: switchStmtList) {
                            stmt.updateRecordState(stmt.getRecordCaseLabel(), v, va.getState());
                            stmt.addVariable(v);
                            if (this.equals(stmt.getLastMethodAccess())) {
                                // check end case equal
                                System.out.println("Check end: " + stmt.isEndCaseSameState());
                                if (!stmt.isEndCaseSameState()) {
                                    problems.add(error("End of case state not match"));
                                }
                            }
                        }
                        if (!this.equals(hostSwitchStmt.getLastMethodAccess())){
                            va.setState(stateMap); // reset state for next check  
                        }                          
                    }
                }               
            }
        }
        // Checking null state argument for all method Access
        if (hasParamWithNullState()) {
            VarAccess arg = getParamWithNullState();
            problems.add(error("No Init State found in MethodAccess argument " + arg));
            return problems;
        } 
  		return problems;
	}

    /**
     * Declarator - C c;
     */
    Declarator contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Declarator.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>(); 
        if (hasTypestateState()) {
            SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable(); // get the symbol table from the host ClassDecl
            if (!hasState()) { // getInit() : Expr
                if ((getInit() != null ) && !(getInit() instanceof NullLiteral)) { // taking care of C c = null; and C c;
                    System.out.println("Init: " + getInit().getClass() + " type: " + getInit().type()); 
                    if (getInit() instanceof ClassInstanceExpr) { // C c = new C();
                        ClassInstanceExpr ins = (ClassInstanceExpr) getInit();
                        setState(ins.getState());
                        setDereferenced(false); // ensure this Declarator is not dereferenced
                        if (this instanceof FieldDeclarator) {
                            st.addGlobal(this, this.getState());
                        } else {
                            st.addCurrLocal(this, this.getState());
                        }
                    } else if (getInit() instanceof VarAccess) { // C c1 = new C(); C c = c1;
                        VarAccess va = (VarAccess) getInit();
                        if (!va.hasTypestateState()) {
                            problems.add(error("Typestate mismatch, no typestate found in source variable access " + va));
                            return problems;
                        }
                        ASTNode d = (ASTNode) va.varDecl();
                        setState(va.getState());
                        d.setState(null); // one typestate object could only have one reference.
                        d.setDereferenced(true);
                        setDereferenced(false); // ensure this Declarator is not dereferenced
                        if (this instanceof FieldDeclarator) {
                            st.addGlobal(this, this.getState());
                        } else {
                            st.addCurrLocal(this, this.getState());
                        }
                    } else if (getInit() instanceof Dot) { // C c = a.get();
                        // TODO: checking return type?
                        Dot d = (Dot) getInit();
                        if (!d.hasTypestateState()) {
                            problems.add(error("Typestate mismatch, no typestate found in source dot " + d));
                            return problems;
                        }
                        setState(d.getState());
                        setDereferenced(false); // ensure this Declarator is not dereferenced
                        if (this instanceof FieldDeclarator) {
                            st.addGlobal(this, this.getState());
                        } else {
                            st.addCurrLocal(this, this.getState());
                        }
                    } else {
                        // TODO analysing other Expr
                    }
                    if (!hasState()) {
                        problems.add(error("No Init State of VariableDeclarator: " + this));
                    }
                }                
            }            
        }
        return problems;
    }

    /**
     * AssignExpr - c1 = c2;
     */
    AssignExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> AssignExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (!getDest().isVariable()) {
            problems.add(error("left hand side is not a variable"));
            return problems;
        }
        if ((getDest().hasTypestateState() ^ getSource().hasTypestateState()) && !(getSource() instanceof NullLiteral)) { // c = null
            problems.add(error("Typestate mismatch. src has typestate? " + getSource().hasTypestateState() 
                + " dest has typestate? " + getDest().hasTypestateState()));
            return problems;
        }
        if (getSource().hasTypestateState()) {  
            //State state = null;
            HashMap<String, State> state = null;
            if (getSource() instanceof VarAccess) { // c = c1
                VarAccess va = (VarAccess) getSource();
                ASTNode d = (ASTNode) va.varDecl();
                state = va.getState();
                d.setState(null); // one typestate object could only have one reference.
                d.setDereferenced(true); 
            } else if (getSource() instanceof ClassInstanceExpr) {
                ClassInstanceExpr ins = (ClassInstanceExpr) getSource();
                state = ins.getState(); 
            } else if (getSource() instanceof Dot) { // c = c1.foo();
                // TODO: checking return type?
                Dot d = (Dot) getSource();
                if (!d.hasTypestateState()) {
                    problems.add(error("Typestate mismatch, no typestate found in source dot " + d));
                    return problems;
                }
                state = d.getState();
            } else {
                // TODO analysing other Expr
            }
            if (getDest() instanceof VarAccess) { 
                VarAccess dva = (VarAccess) getDest();
                ASTNode dest = (ASTNode)dva.varDecl();
                dest.setDereferenced(false); // ensure this dest is not dereferenced
                dest.setState(state);
            } else {
                problems.add(error("Cannot set state"));
            }
        }        
        return problems;
    }

    ClassInstanceExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassInstanceExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (this.hasTypestateState()) {
            if (!this.hasState()) {
                problems.add(error("ClassInstanceExpr has no Init state"));
                return problems;
            } else if (this.getState().size() > 1) {
                problems.add(error("ClassInstanceExpr should be in Init state instead of a TypestateSwitch"));
                return problems;
            } else { //if (!this.getState().equals(type().getTypestateDecl().getInitState())) {
                State state = getSingleStateFromMap(this.getState());
                if (!this.getState().containsKey(type().getTypestateDecl().getInitState().getID())) {
                    problems.add(error("ClassInstanceExpr should be in Init state instead of " + ((state != null) ? state.getID() : "null")));
                }                
            }
        }
        return problems;
    }

    MethodDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> MethodDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        Block block = getBlock();
        SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable();
        System.out.println("MethodDecl " + this +  " host class SymbolTable globals size: " + st.getGlobals().size());
        // if SymbolTable local stack is empty, push new table with ParameterDeclarator information on it
        // if not empty, clear it and push the new table on it
        if (!st.getLocals().empty()) {
            st.clearLocals();
        }
        HashMap<Variable, HashMap<String, State>> map = new HashMap<Variable, HashMap<String, State>>();
        st.addLocal(map);

        if (hasTypestateDecl()) {
            TypestateDecl td = this.hostType().getTypestateDecl();
            TypestateMethod tm = td.lookupMethod(this);
            // Update ParameterDeclaration state and add ParameterDeclaration to local symbol table
            if (tm != null) {
                for (int i = 0; i < this.getNumParameter(); i++){
                    ParameterDeclaration mdParam = getParameter(i);
                    TType tmParam = tm.getTTypeList().getTType(i);
                    if (mdParam.hasTypestateState()) {
                        if (!(tmParam instanceof TTypestate)) {
                            problems.add(error("Cannot find valid Typestate specification for ParameterDeclaration: " + mdParam));
                        } else {
                            TTypestate tt = (TTypestate) tmParam;
                            Typestate ts = tt.getTypestate();
                            if (ts instanceof TypestateLabel) {
                                TypestateLabel tl = (TypestateLabel) ts;
                                HashMap<String, State> state = new HashMap<String, State>();
                                state.put(tl.getLabel(), td.lookupState(tl.getLabel()));
                                mdParam.setState(state); // Update state
                                st.addCurrLocal(mdParam, mdParam.getState()); // Update symbol table
                            } else if (ts instanceof TypestateSwitch) {
                                // TODO setting ParameterDeclaration state for TypestateSwitch
                                
                            }
                        }
                    }              
                }
                if (problems.size() != 0) {
                    return problems;
                }
            }
            System.out.println("MethodDecl SymbolTable locals size: " + st.getLocals().size());
            System.out.println("MethodDecl local size: " + st.currentLocal().size());


            // Check return type
            if (!(this.getTypeAccess() instanceof PrimitiveTypeAccess)) { // PrimitiveTypeAccess will not have TypestateDecl
                if (returnHasTypestateDecl()) { // Both hostType and return type has TypestateDecl
                    if (tm == null) {
                        problems.add(error("Cannot find corresponding TypestateMethod in TypestateDecl"));
                        return problems;
                    }
                    if (block != null) { // Do not check return statement of abstract method declaration
                        for (Stmt s: block.getStmts()) { // All statements in MethodDecl block
                            if (s instanceof ReturnStmt) {
                                ReturnStmt rs = (ReturnStmt)s;
                                if (!tm.isSameReturnState(rs)) { // State mismatch, report error
                                    problems.add(error("ReturnStmt Typestate mismatch"));
                                    return problems;
                                }
                            }
                        }
                    }
                }            
            } 
        }            
        return problems;
    }

    ConstCase contributes each typestateProblem() to CompilationUnit.problems();
    syn Collection<Problem> ConstCase.typestateProblem() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        SwitchStmt switchStmt = lookupSwitch();
        if (switchStmt != null) {
            HashMap<Stmt, StmtInfo> infoMap = switchStmt.getStmtInfoMap();
            StmtInfo info = infoMap.get(this);
            if (info != null){
                if (!info.hasTermination()) {
                    problems.add(error("Case with label: " + getValue() + " in Typestate switch has no break or continue statement."));
                    return problems;
                }
            } 
        }        
        return problems;
    }

    /**
     * TODO Look up variables, check and update their states.
     *
     * switch (a.isFoo()) {...}
     *
     * Choice c = a.isFoo();
     * switch (c) {...}
     * 
     * In both cases, state of a need to be updated
     */
    SwitchStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> SwitchStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("SwitchStmt Typestate? " + hasTypestateDecl()); 
        if (hasTypestateDecl()) {
            if (this.getRecordVariable() == null) {
                this.initRecordVariable();
                System.out.println("Record Variable: " + this.getRecordVariable() + " " + this.getRecordVariable().getClass());
                System.out.println("Test variable typestate: " + this.getRecordVariable().getState());
            }   
            if (this.getRecordVariable() == null) {
                problems.add(error("Cannot find record variable of this typstate switch statement"));
                return problems;
            } else {
                LinkedList<MethodAccess> methodList = this.collectMethodAccess();
                this.setLastMethodAccess(methodList.getLast());
                System.out.println("Num methods in SwitchStmt: "+ methodList.size() + " last " + this.getLastMethodAccess());
            }
        }
        return problems;
    }

    LabeledStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> LabeledStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("LabeledStmt label: " + getLabel());
        return problems;
    }

    Case contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Case.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //this.doPrintFullTraversal();
        return problems;
    }

    BreakStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> BreakStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("BreakStmt target: " + targetStmt());
        return problems;
    }

    /** Unused */
    ReturnStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ReturnStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("ReturnStmt class: " + returnType());
        //System.out.println("ReturnStmt result: " + getResult() + " " + getResult().getClass());
        return problems;
    }

    Dot contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Dot.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("varDecl of Dot: " + this + " " + this.varDecl());
        return problems;
    }

    VarAccess contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarAccess.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (hasTypestateDecl() && !hasState() ) {
            //problems.add(error("No Init State found in VarAccess " + this));
        }       
        return problems;
    }    

    VarDeclStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarDeclStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("VarDeclStmt: " + this + " " +this.lineNumber());
        //System.out.println("VarDeclStmt Declarators: ");
        for (VariableDeclarator vd: getDeclarators()){
            //System.out.println(vd);
        }
        return problems;
    }
}