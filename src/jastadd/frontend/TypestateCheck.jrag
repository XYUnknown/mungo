/**
 * Typestate checking in each node of the AST
 * Every node contribute typestate problems to compilation unit problem collection
 */
aspect TypestateCheck {
    /**
     * Typestate checking in TypeDecl
     */
    TypeDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> TypeDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a TypeDecl could have at most one typestate annotation
            problems.add(error("A TypeDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }   
        return problems;
    }

    /**
     * Typestate checking in ClassDecl
     * ClassDecl: TypeDecl
     */
    ClassDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        TypestateDecl td = this.getTypestateDecl();
        if (!validNumTypestateAnnotation()) { // a ClassDecl could have at most one typestate annotation
            problems.add(error("A ClassDecl could have at most one typestate annotation."));
        }
        if (hasTypestateAnnotation() && (td == null)) { // the annotation is found but no AST
            problems.add(error("There is no AST contructed from typestate protocol: " + getTypestateAnnotation().getID()));
        }
        LinkedList<HashMap<Variable, HashMap<String, State>>> globalSymbolList = this.collectGlobals();
        this.addAllGlobals(globalSymbolList); 
        System.out.println("Global symbol table size: " + this.getSymbolTable().getGlobals().size());    
        return problems;
    }

    /**
     * MethodAccess: c.foo()
     * From a MethodAccess we could get VariableAccess and MethodDecl
     */
	MethodAccess contributes each typestateProblems() to CompilationUnit.problems();
  	syn Collection<Problem> MethodAccess.typestateProblems() {
  		LinkedList<Problem> problems = new LinkedList<Problem>();

        //-------printing for debug-------//
        System.out.println("---------checking------------");
        System.out.println("MethodAccess name: " + name() + " /hostType: " + this.hostType() + " /Type: " + this.type() + " /decl hostType: " + decl().hostType()); 
        if (((ClassDecl)hostType()).getSymbolTable()!= null){ 
            System.out.println("SymbolTable info: globals size " + 
            ((ClassDecl)hostType()).getSymbolTable().getGlobals().size() + " locals size: " + 
            ((ClassDecl)hostType()).getSymbolTable().getLocals().size() + " current local size: " +
            ((((ClassDecl)hostType()).getSymbolTable().getLocals().size() == 0) ? 0 : ((ClassDecl)hostType()).getSymbolTable().currentLocal().size()));
        }
        //-------end-------//

        SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable(); // load host class symbol table

        if(hasPrevExpr()) { // avoid situation such as 1) implicit self reference 2) static method
            System.out.println("MethodAccess preExpr: " + prevExpr() + " " + prevExpr().getClass());
            Expr va = prevExpr();
            if (va.hasTypestateState() && !va.hasState()) { // if va does not have state, report error
                problems.add(error("No Init State found in VarAccess " + va));
                return problems;
            }
            if (va.hasTypestateState() && va.hasState()) {
                if (!va.isVariable()) { // Expr va is not a variable
                    MethodDecl md = this.decl();
                    HashMap<String, State> stateMap = va.getState();
                    if (stateMap.size() == 0){
                        // End of state error reporting
                        problems.add(error("Reach end of state " + va));
                        return problems;
                    } else if (stateMap.size() == 1) { // No switch
                        // Typestate checking and state updating
                        State currState = getSingleStateFromMap(stateMap);                 
                        problems = collectProblems(currState, md, va);
                        if (problems.size() != 0) {
                            return problems;
                        }
                    } else {
                        problems.add(error("Invalid MethodAccess " + this + " in non-variable TypestateSwitch State."));
                        return problems;
                    }
                } else { // Expr va is a variable
                    MethodDecl md = this.decl();
                    Variable variable = va.varDecl();
                    // Lookup the state of the variable in symble table
                    HashMap<String, State> stateMap = st.lookupVariableState(variable);
                    if (stateMap == null) {
                        problems.add(error("Cannot find state of variable " + variable + " in SymbolTable"));
                        return problems;
                    }
                    //_____________
                    if (stateMap.size() == 0){
                        // End of state error reporting
                        problems.add(error("Reach end of state " + va));
                        return problems;
                    } else if (stateMap.size() == 1) {
                        // Typestate checking and state updating
                        State currState = getSingleStateFromMap(stateMap); 
                        problems = collectProblems(currState, md, va); // 
                        if (problems.size() != 0) {
                            return problems;
                        }
                        System.out.println(this + " isSwitchStmtExpr? " + this.isSwitchStmtExpr());
                        if (this.isSwitchStmtExpr()) {
                            SwitchStmt hostSwitch = this.lookupExprSwitchStmt();
                            // init all the records and maps here
                            if (this.getTargetState() == null) {
                                problems.add(error("MethodAccess " + this + " with null target state should not be the Expr of SwitchStmt."));
                                return problems;
                            } else if (this.getTargetState().size() < 2) {
                                problems.add(error("MethodAccess " + this + " without a target TypestateSwitch should not be the Expr of SwitchStmt."));
                                return problems;
                            } else {
                                hostSwitch.setRecordTypestateSwitch(this.getTargetState());
                                hostSwitch.getStmtInfoMap(); // initialise stmt information map
                                hostSwitch.addVariable(hostSwitch.getRecordVariable());
                            }
                        } 
                        // update SymbolTable locals
                        st.addCurrLocal(va.varDecl(), va.getState());
                    } else { // Still in switch state, not processed by valid case, report error
                        problems.add(error("Invalid MethodAccess " + this + " in TypestateSwitch State."));
                        return problems;
                    }
                    //_____________
                }              
            }
        }
        // Checking null state argument for all method Access
        if (hasParamWithNullState()) {
            VarAccess arg = getParamWithNullState();
            problems.add(error("No Init State found in MethodAccess argument " + arg));
            return problems;
        } 
  		return problems;
	}

    /**
     * Declarator - C c;
     */
    Declarator contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Declarator.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>(); 
        if (hasTypestateState()) {
            SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable(); // get the symbol table from the host ClassDecl
            if (!hasState()) { // getInit() : Expr
                if ((getInit() != null ) && !(getInit() instanceof NullLiteral)) { // taking care of C c = null; and C c;
                    System.out.println("Init: " + getInit().getClass() + " type: " + getInit().type()); 
                    if (getInit() instanceof ClassInstanceExpr) { // C c = new C();
                        ClassInstanceExpr ins = (ClassInstanceExpr) getInit();
                        setState(ins.getState());
                        setDereferenced(false); // ensure this Declarator is not dereferenced
                        /* *
                         * Update symbol table, store field declarator state in globals and variable declarators in locals
                         */
                        if (this instanceof FieldDeclarator) {
                            st.addGlobal(this, this.getState());
                        } else {
                            st.addCurrLocal(this, this.getState());
                        }
                    } else if (getInit() instanceof VarAccess) { // C c1 = new C(); C c = c1;
                        VarAccess va = (VarAccess) getInit();
                        if (!va.hasTypestateState()) {
                            problems.add(error("Typestate mismatch, no typestate found in source variable access " + va));
                            return problems;
                        }
                        ASTNode d = (ASTNode) va.varDecl();
                        setState(va.getState());
                        d.setState(null); // one typestate object could only have one reference.
                        d.setDereferenced(true);
                        setDereferenced(false); // ensure this Declarator is not dereferenced
                        if (this instanceof FieldDeclarator) {
                            st.addGlobal(this, this.getState());
                        } else {
                            st.addCurrLocal(this, this.getState());
                        }
                        /*
                         * Dereference - remove from symbol table
                         */
                        if (d instanceof FieldDeclarator) {
                            if (st.getGlobals().containsKey(d)) {
                                st.getGlobals().remove(d);
                            }
                        } else {
                            if (st.currentLocal().containsKey(d)) {
                                st.currentLocal().remove(d);
                            }
                        }
                    } else if (getInit() instanceof Dot) { // C c = a.get();
                        // TODO: checking return type?
                        Dot d = (Dot) getInit();
                        if (!d.hasTypestateState()) {
                            problems.add(error("Typestate mismatch, no typestate found in source dot " + d));
                            return problems;
                        }
                        setState(d.getState());
                        setDereferenced(false); // ensure this Declarator is not dereferenced
                        if (this instanceof FieldDeclarator) {
                            st.addGlobal(this, this.getState());
                        } else {
                            st.addCurrLocal(this, this.getState());
                        }
                    } else {
                        // TODO analysing other Expr
                    }
                    if (!hasState()) {
                        problems.add(error("No Init State of VariableDeclarator: " + this));
                    }
                }                
            }            
        }
        return problems;
    }

    /**
     * AssignExpr - c1 = c2;
     */
    AssignExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> AssignExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("AssignExpr: " + this.lineNumber());
        if (!getDest().isVariable()) {
            problems.add(error("left hand side is not a variable"));
            return problems;
        }
        if ((getDest().hasTypestateState() ^ getSource().hasTypestateState()) && !(getSource() instanceof NullLiteral)) { // c = null
            problems.add(error("Typestate mismatch. src has typestate? " + getSource().hasTypestateState() 
                + " dest has typestate? " + getDest().hasTypestateState()));
            return problems;
        }
        SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable();
        if (getSource().hasTypestateState()) {  
            //State state = null;
            HashMap<String, State> state = null;
            if (getSource() instanceof VarAccess) { // c = c1
                VarAccess va = (VarAccess) getSource();
                ASTNode d = (ASTNode) va.varDecl();
                state = va.getState();
                d.setState(null); // one typestate object could only have one reference.
                d.setDereferenced(true); 
                // remove from symbol table (only local)
                if (st.currentLocal().containsKey(d)) {
                    st.currentLocal().remove(d);
                }
            } else if (getSource() instanceof ClassInstanceExpr) {
                ClassInstanceExpr ins = (ClassInstanceExpr) getSource();
                state = ins.getState(); 
            } else if (getSource() instanceof Dot) { // c = c1.foo();
                // TODO: checking return type?
                Dot d = (Dot) getSource();
                if (!d.hasTypestateState()) {
                    problems.add(error("Typestate mismatch, no typestate found in source dot " + d));
                    return problems;
                }
                state = d.getState();
            } else {
                // TODO analysing other Expr
            }

            if (getDest() instanceof VarAccess) { 
                VarAccess dva = (VarAccess) getDest();
                ASTNode dest = (ASTNode)dva.varDecl();
                dest.setDereferenced(false); // ensure this dest is not dereferenced
                dest.setState(state);
                // AssignExpr is always within MethodDecl local scope, both FieldDeclarator and VariableDeclarator
                // states are recorded in locals.
                st.addCurrLocal(((Variable)dest), dest.getState());
            } else {
                problems.add(error("Cannot set state"));
            }
        }        
        return problems;
    }

    ClassInstanceExpr contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ClassInstanceExpr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (this.hasTypestateState()) {
            if (!this.hasState()) {
                problems.add(error("ClassInstanceExpr has no Init state"));
                return problems;
            } else if (this.getState().size() > 1) {
                problems.add(error("ClassInstanceExpr should be in Init state instead of a TypestateSwitch"));
                return problems;
            } else { //if (!this.getState().equals(type().getTypestateDecl().getInitState())) {
                State state = getSingleStateFromMap(this.getState());
                if (!this.getState().containsKey(type().getTypestateDecl().getInitState().getID())) {
                    problems.add(error("ClassInstanceExpr should be in Init state instead of " + ((state != null) ? state.getID() : "null")));
                }                
            }
        }
        return problems;
    }

    MethodDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> MethodDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        Block block = getBlock();
        SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable();
        System.out.println("MethodDecl " + this +  " host class SymbolTable globals size: " + st.getGlobals().size());
        // if SymbolTable local stack is empty, push new table with ParameterDeclarator information on it
        // if not empty, clear it and push the new table on it
        if (!st.getLocals().empty()) {
            st.clearLocals();
        }
        HashMap<Variable, HashMap<String, State>> map = new HashMap<Variable, HashMap<String, State>>();
        st.addLocal(map);

        if (hasTypestateDecl()) {
            TypestateDecl td = this.hostType().getTypestateDecl();
            TypestateMethod tm = td.lookupMethod(this);
            // Update ParameterDeclaration state and add ParameterDeclaration to local symbol table
            if (tm != null) {
                for (int i = 0; i < this.getNumParameter(); i++){
                    ParameterDeclaration mdParam = getParameter(i);
                    TType tmParam = tm.getTTypeList().getTType(i);
                    if (mdParam.hasTypestateState()) {
                        if (!(tmParam instanceof TTypestate)) {
                            problems.add(error("Cannot find valid Typestate specification for ParameterDeclaration: " + mdParam));
                        } else {
                            TTypestate tt = (TTypestate) tmParam;
                            Typestate ts = tt.getTypestate();
                            if (ts instanceof TypestateLabel) {
                                TypestateLabel tl = (TypestateLabel) ts;
                                HashMap<String, State> state = new HashMap<String, State>();
                                state.put(tl.getLabel(), td.lookupState(tl.getLabel()));
                                mdParam.setState(state); // Update state
                                st.addCurrLocal(mdParam, mdParam.getState()); // Update symbol table
                            } else if (ts instanceof TypestateSwitch) {
                                // TODO setting ParameterDeclaration state for TypestateSwitch
                                
                            }
                        }
                    }              
                }
                if (problems.size() != 0) {
                    return problems;
                }
            }
            System.out.println("MethodDecl SymbolTable locals size: " + st.getLocals().size());
            System.out.println("MethodDecl local size: " + st.currentLocal().size());

            // Check return type
            if (!(this.getTypeAccess() instanceof PrimitiveTypeAccess)) { // PrimitiveTypeAccess will not have TypestateDecl
                if (returnHasTypestateDecl()) { // Both hostType and return type has TypestateDecl
                    if (tm == null) {
                        problems.add(error("Cannot find corresponding TypestateMethod in TypestateDecl"));
                        return problems;
                    }
                    if (block != null) { // Do not check return statement of abstract method declaration
                        for (Stmt s: block.getStmts()) { // All statements in MethodDecl block
                            if (s instanceof ReturnStmt) {
                                ReturnStmt rs = (ReturnStmt)s;
                                if (!tm.isSameReturnState(rs)) { // State mismatch, report error
                                    problems.add(error("ReturnStmt Typestate mismatch"));
                                    return problems;
                                }
                            }
                        }
                    }
                }            
            } 
        }            
        return problems;
    }

    /**
     * ConstructorDecl does not have return type
     */
    ConstructorDecl contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ConstructorDecl.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        Block block = getBlock();
        SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable();
        System.out.println("ConstructorDecl " + this +  " host class SymbolTable globals size: " + st.getGlobals().size());
        // if SymbolTable local stack is empty, push new table with ParameterDeclarator information on it
        // if not empty, clear it and push the new table on it
        if (!st.getLocals().empty()) {
            st.clearLocals();
        }
        HashMap<Variable, HashMap<String, State>> map = new HashMap<Variable, HashMap<String, State>>();
        st.addLocal(map);     
        return problems;
    }

    ConstCase contributes each typestateProblem() to CompilationUnit.problems();
    syn Collection<Problem> ConstCase.typestateProblem() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        SwitchStmt switchStmt = lookupSwitch();
        if ((switchStmt != null) && switchStmt.hasTypestateDecl()) {
            HashMap<Stmt, StmtInfo> infoMap = switchStmt.getStmtInfoMap();
            StmtInfo info = infoMap.get(this);
            if (info != null){
                if (!info.hasTermination()) {
                    problems.add(error("Case with label: " + getValue() + " in Typestate switch has no break or continue statement."));
                    return problems;
                }
                // Push a new table on locals for valid case in a typestate switch stmt
                if (!this.isDereferenced()) { // not dereferenced means label is valid
                    SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable(); // load host class symbol tables
                    HashMap<Variable, HashMap<String, State>> caseLocals = new HashMap<Variable, HashMap<String, State>>();
                    Variable v = switchStmt.getRecordVariable();
                    State s = switchStmt.getRecordTypestateSwitch().get(info.getCaseLabel());
                    HashMap <String, State> state = new HashMap<String, State>();
                    state.put(s.getID(), s);
                    caseLocals.put(v, state);
                    st.addLocal(caseLocals);
                }
            }
        }        
        return problems;
    }

    BreakStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> BreakStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("BreakStmt target: " + targetStmt());
        SwitchStmt switchStmt = lookupSwitch();
        if ((switchStmt != null) && switchStmt.hasTypestateDecl()) {
            HashMap<Stmt, StmtInfo> infoMap = switchStmt.getStmtInfoMap();
            StmtInfo info = infoMap.get(this);
            if ((info != null) && (!this.isDereferenced())) {
                SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable();
                BranchTargetStmt targetStmt = (BranchTargetStmt) this.targetStmt();
                // if target is labeled stmt, get the internal statement from it
                if (targetStmt instanceof LabeledStmt) {
                    System.out.println("Target is LabeledStmt: " + targetStmt);
                    Stmt stmt = ((LabeledStmt)targetStmt).getStmt();
                    if (stmt instanceof BranchTargetStmt) {
                        targetStmt = (BranchTargetStmt) stmt;
                    } else {
                        problems.add(error("Target statement is not branchable"));
                        return problems;
                    }
                }
                if (info.isLastStmt()) {
                    // pop, check, store state
                    int size = switchStmt.caseMap().size();
                    System.out.println("BreakStmt size check " + size);
                    HashMap<Variable, HashMap<String, State>> map = st.currentLocal();
                    for (Variable v : map.keySet()) {
                        if ((targetStmt.getVarList() == null) || (!targetStmt.getVarList().contains(v))) {
                            targetStmt.addVariable(v);
                        }
                    }
                    targetStmt.addRecordState(st.exitLocal());
                    boolean isSameContinueEndState = targetStmt.hasContinueStateMapList()? targetStmt.isContinueEndCaseSameState(): true;
                    if (!isSameContinueEndState) {
                        problems.add(error("Variables end at different state for ContinueStmts."));
                        return problems;
                    }
                    boolean isSameEndState = targetStmt.hasBreakStateMapList()? targetStmt.isEndCaseSameState(): true;
                    if (!isSameEndState) {
                        problems.add(error("Variables end at different state for BreakStmts."));
                        return problems;
                    }
                    st.exitLocal(); // exit current switch
                    st.currentLocal().putAll(targetStmt.getStateMapList().get(0));

                } else {
                    HashMap<Variable, HashMap<String, State>> map = st.currentLocal();
                    for (Variable v : map.keySet()) {
                        if ((targetStmt.getVarList() == null) || (!targetStmt.getVarList().contains(v))) {
                            targetStmt.addVariable(v);
                        }
                    }
                    targetStmt.addRecordState(st.exitLocal());
                }
            }
        }
        return problems;
    }

    ContinueStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ContinueStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("ContinueStmt target: " + targetStmt());
        SwitchStmt switchStmt = lookupSwitch();
        if ((switchStmt != null) && switchStmt.hasTypestateDecl()) {
            HashMap<Stmt, StmtInfo> infoMap = switchStmt.getStmtInfoMap();
            StmtInfo info = infoMap.get(this);
            if ((info != null) && (!this.isDereferenced())) {
                SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable();
                BranchTargetStmt targetStmt = (BranchTargetStmt) this.targetStmt();
                // if target is labeled stmt, get the internal statement from it
                if (targetStmt instanceof LabeledStmt) {
                    System.out.println("Target is LabeledStmt: " + targetStmt);
                    Stmt stmt = ((LabeledStmt)targetStmt).getStmt();
                    if (stmt instanceof BranchTargetStmt) {
                        targetStmt = (BranchTargetStmt) stmt;
                    } else {
                        problems.add(error("Target statement is not branchable"));
                        return problems;
                    }
                }
                if (info.isLastStmt()) {
                    // pop, check, store state
                    int size = switchStmt.caseMap().size();
                    System.out.println("ContinueStmt size check " + size);
                    HashMap<Variable, HashMap<String, State>> map = st.currentLocal();
                    for (Variable v : map.keySet()) {
                        if ((targetStmt.getVarList() == null) || (!targetStmt.getVarList().contains(v))) {
                            targetStmt.addVariable(v);
                        }
                    }
                    targetStmt.addRecordContinueState(st.exitLocal());
                    boolean isSameContinueEndState = targetStmt.hasContinueStateMapList()? targetStmt.isContinueEndCaseSameState(): true;
                    if (!isSameContinueEndState) {
                        problems.add(error("Variables end at different state for ContinueStmts."));
                        return problems;
                    }
                    boolean isSameEndState = targetStmt.hasBreakStateMapList()? targetStmt.isEndCaseSameState(): true;
                    if (!isSameEndState) {
                        problems.add(error("Variables end at different state for BreakStmts."));
                        return problems;
                    }
                    st.exitLocal(); // exit current switch
                    //st.currentLocal().putAll(targetStmt.getContinueStateMapList().get(0));
                    st.currentLocal().putAll(targetStmt.getStateMapList().get(0));

                } else {
                    HashMap<Variable, HashMap<String, State>> map = st.currentLocal();
                    for (Variable v : map.keySet()) {
                        if ((targetStmt.getVarList() == null) || (!targetStmt.getVarList().contains(v))) {
                            targetStmt.addVariable(v);
                        }
                    }
                    targetStmt.addRecordContinueState(st.exitLocal());
                }
            }
        }
        return problems;
    }

    SwitchStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> SwitchStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("SwitchStmt Typestate? " + hasTypestateDecl());
        System.out.println("SwitchStmt branches? " + branches().size());
        SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable(); // load host class symbol tables 
        if (hasTypestateDecl()) {
            if (this.getRecordVariable() == null) {
                this.initRecordVariable();
                System.out.println("Record Variable: " + this.getRecordVariable() + " " + this.getRecordVariable().getClass());
                System.out.println("Test variable typestate: " + this.getRecordVariable().getState());
            }   
            if (this.getRecordVariable() == null) {
                problems.add(error("Cannot find record variable of this typestate switch statement"));
                return problems;
            } else {
                // SwitchStmt, push a new local table on locals stack
                HashMap<Variable, HashMap<String, State>> switchLocals = new HashMap<Variable, HashMap<String, State>>();
                st.addLocal(switchLocals);
            }
        }
        return problems;
    }

    LabeledStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> LabeledStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        System.out.println("LabeledStmt label: " + getLabel());
        System.out.println("LabeledStmt stmt: " + getStmt().getClass());        
        return problems;
    }

    DoStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> DoStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable(); // load host class symbol tables
        setInitialTable(st.currentLocal()); // set initial table for continue statement consistency checking
        HashMap<Variable, HashMap<String, State>> doLocals = new HashMap<Variable, HashMap<String, State>>();
        st.addLocal(doLocals);
        System.out.println("DoStmt: " + this.getCondition() + " " + this.getCondition().isLoopCondition());
        this.getCondition().setIsLoopCondition(true); // set condition expr label true
        this.getCondition().setHostStmt(this); // set condition expr host statement
        System.out.println("DoStmt: " + this.getCondition() + " " + this.getCondition().isLoopCondition());
        return problems; 
    }

    /**
     * End of a DoStmt pop local symbol table.
     * I am not sure why Literal need to be mentioned explicitly here, otherwise there are bugs
     */
    Expr contributes each typestateProblems() when (this.isLoopCondition() || (this instanceof Literal))to CompilationUnit.problems();
    syn Collection<Problem> Expr.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        SymbolTable st = ((ClassDecl)this.hostType()).getSymbolTable();
        if (this.isLoopCondition()) {
            System.out.println("Condition Expr: " + this);
            System.out.println("Before Condition Expr local size: " + st.getLocals().size());
            HashMap<Variable, HashMap<String, State>> loopMap = st.exitLocal();
            BranchTargetStmt hostStmt = this.getHostStmt();
            if (hostStmt == null) {
                problems.add(error("Cannot find host statement of " + this));
                return problems;
            } else {
                if (hostStmt.hasContinueStateMapList()) {
                    for (HashMap<Variable, HashMap<String, State>> map: hostStmt.getContinueStateMapList()) {
                        if (!hostStmt.isValidContinueState(map)) {
                            problems.add(error("Variable's state at the end of contiune statements does not match its state at the beginning of loop."));
                            return problems;
                        }
                    }
                }
            }           
            st.currentLocal().putAll(loopMap);
            System.out.println("After Condition Expr local size: " + st.getLocals().size());
        }        
        return problems;
    }

    /*Literal contributes each typestateProblems() when this.isLoopCondition() to CompilationUnit.problems();
    syn Collection<Problem> Literal.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();  
        if (this.isLoopCondition()) {
            System.out.println("Literal Condition Expr: " + this);
        }
        return problems;
    }*/

    /** Unused */
    /*
    Case contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Case.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //this.doPrintFullTraversal();
        return problems;
    }

    ReturnStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> ReturnStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("ReturnStmt class: " + returnType());
        //System.out.println("ReturnStmt result: " + getResult() + " " + getResult().getClass());
        return problems;
    }

    Dot contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> Dot.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("varDecl of Dot: " + this + " " + this.varDecl());
        return problems;
    }

    VarAccess contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarAccess.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        if (hasTypestateDecl() && !hasState() ) {
            //problems.add(error("No Init State found in VarAccess " + this));
        }       
        return problems;
    }    

    VarDeclStmt contributes each typestateProblems() to CompilationUnit.problems();
    syn Collection<Problem> VarDeclStmt.typestateProblems() {
        LinkedList<Problem> problems = new LinkedList<Problem>();
        //System.out.println("VarDeclStmt: " + this + " " +this.lineNumber());
        //System.out.println("VarDeclStmt Declarators: ");
        for (VariableDeclarator vd: getDeclarators()){
            //System.out.println(vd);
        }
        return problems;
    }
    */
}