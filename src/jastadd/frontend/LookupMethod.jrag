aspect LookupMethod {
	/**
     * Getting variable access from a method access
     * a.b.c()
     * a.b().c()
     */
    private VarAccess MethodAccess.getVarAccess(){
        Expr ac = this.parentDot().leftSide();
        //System.out.println("--------------Traversal---------------");
        //this.parentDot().doPrintFullTraversal();
        //System.out.println("--------------End Traversal-----------");
        while (!(ac instanceof VarAccess) && (ac != null)){
            if (ac.parentDot().parentDot() == null){
                if(ac instanceof Dot){
                    Dot dot = (Dot) ac;
                    while (dot.rightSide() != null) {
                        ac = dot.rightSide();
                        if (ac instanceof VarAccess) {
                            return (VarAccess) ac;
                        } else if (ac instanceof Dot) {
                            dot = (Dot) ac;
                        } else {
                            return null;
                        }
                    }
                } else {
                    return null;
                }
            }
            ac = ac.parentDot().parentDot().leftSide();
        }
        return ac == null ? null : (VarAccess) ac;
    }

	/**
	 * Collecting all ClassInstanceExpr
	 */
	coll LinkedList<ClassInstanceExpr> CompilationUnit.collectClassInstanceExpressions() root CompilationUnit;
    ConstructorDecl contributes {
        if (checkImplicitConstructorInvocation()) {
            getImplicitConstructorInvocation().collectContributions();
        }
        super.collectContributions();
    } to CompilationUnit.collectClassInstanceExpressions();

    ClassInstanceExpr contributes each classInstanceExpressions() to CompilationUnit.collectClassInstanceExpressions();
    syn Collection<ClassInstanceExpr> ClassInstanceExpr.classInstanceExpressions() {
        LinkedList<ClassInstanceExpr> list = new LinkedList<ClassInstanceExpr>();
        list.add(this);
        return list;
    }

    /**
	 * Collecting all VarDeclStmt
	 */
	coll LinkedList<VarDeclStmt> CompilationUnit.collectVarDeclStmts() root CompilationUnit;
    ConstructorDecl contributes {
        if (checkImplicitConstructorInvocation()) {
            getImplicitConstructorInvocation().collectContributions();
        }
        super.collectContributions();
    } to CompilationUnit.collectVarDeclStmts();

    VarDeclStmt contributes each varDeclStmts() to CompilationUnit.collectVarDeclStmts();
    syn Collection<VarDeclStmt> VarDeclStmt.varDeclStmts() {
        LinkedList<VarDeclStmt> list = new LinkedList<VarDeclStmt>();
        list.add(this);
        return list;
    }

    /**
     * Checking whether a VarDeclStmt contains a specific ClassInstanceExpr
     */
    public boolean VarDeclStmt.containsClassInstanceExpr(ClassInstanceExpr c) {
    	if (!this.getTypeAccess().type().equals(c.type())){
    		return false;
    	}
    	int stmtStartLine = getLine(getStart());
    	int stmtEndLine = getLine(getEnd());
    	int cStartLine = getLine(c.getStart());
    	int cEndLine = getLine(c.getEnd());
    	return (stmtStartLine <= cStartLine) && (stmtEndLine >= cEndLine);
    }

    /**
     * Checking whether a VarDeclStmt contains ClassInstanceExpr
     */
    public boolean VarDeclStmt.hasClassInstanceExpr(){
    	LinkedList<ClassInstanceExpr> list = this.compilationUnit().collectClassInstanceExpressions();
        for (ClassInstanceExpr c: list) {
            if (this.containsClassInstanceExpr(c)){
                return true;
            }
        }
        return false;
    }

    /**
     * Get return type of a TypestateMethod
     */
    public Access TypestateMethod.getReturnType() {
    	return getTType().getAccess();
    }

    /**
     * Check whether a MethodDecl has the same return type as a TypestateMethod
     */
    public boolean MethodDecl.isSameReturnType(TypestateMethod tm) {
    	Access mdReturn = this.getTypeAccess();
    	Access tmReturn = tm.getReturnType();
    	if (mdReturn.getClass().equals(tmReturn.getClass())) {
			if(mdReturn.toString().equals(tmReturn.toString())){ // Better way to check than toString() ? 
				return true;
			}
    	}
    	return false;    	
    }

    /**
     * Check whether a MethodDecl has the same name as a TypestateMethod
     */
    public boolean MethodDecl.isSameName(TypestateMethod tm) {
    	return this.name().equals(tm.getID());    	
    }

    /**
     * Check whether a MethodDecl has the same parameter list as a TypestateMethod
     */
    public boolean MethodDecl.isSameParamList(TypestateMethod tm) {
    	if (this.getNumParameter() == tm.getTTypeList().getNumTType()) {
    		Access mdParam, tmParam;
    		for (int i = 0; i < this.getNumParameter(); i++){
    			mdParam = getParameter(i).getTypeAccess();
    			tmParam = tm.getTTypeList().getTType(i).getAccess();
    			if (!mdParam.getClass().equals(tmParam.getClass())){
    				return false;
    			}
    			if(!mdParam.toString().equals(tmParam.toString())){ //Better way to check than toString() ?
    				return false;
    			}    			
    		}
    		return true;
    	}
    	return false;    	
    }

    /**
     * Check whether a MethodDecl has the same signature as a TypestateMethod
     */
    public boolean MethodDecl.isSameSignature(TypestateMethod tm) {
    	return isSameReturnType(tm) &&isSameName(tm) && isSameParamList(tm);
    }

    syn State VariableDeclarator.getTypestateInitState() = type().getTypestateDecl().getInitState();

    


}