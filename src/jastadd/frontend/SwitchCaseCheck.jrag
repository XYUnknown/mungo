aspect SwitchCaseCheck {
	coll LinkedList<Problem> SwitchStmt.collectTypestateProblems() root SwitchStmt;
	ConstructorDecl contributes {
		if (checkImplicitConstructorInvocation()) {
			getImplicitConstructorInvocation().collectContributions();
		}
		super.collectContributions();
	} to SwitchStmt.collectTypestateProblems();

	private boolean SwitchStmt.checked = false;

	public void SwitchStmt.setCheckedTrue() {
		this.checked = true;
	} 

	public boolean SwitchStmt.isChecked() {
		return this.checked;
	}

	/**
	 * Determine a MethodAccess is checked or not
	 */
	private boolean MethodAccess.checked = false;

	public void MethodAccess.setCheckedTrue() {
		this.checked = true;
	} 

	public void MethodAccess.setCheckedFalse() {
		this.checked = false;
	}

	public boolean MethodAccess.isChecked() {
		return this.checked;
	}

	/**
	 * Record result state and case label
	 */
	private HashMap<String, State> SwitchStmt.recordState;

	public HashMap<String, State> SwitchStmt.getRecordState() {
		return this.recordState;
	}

	public void SwitchStmt.setRecordState(HashMap<String, State> state) {
		this.recordState = state;
	}

	private String SwitchStmt.recordCaseLabel;

	public String SwitchStmt.getRecordCaseLabel() {
		return this.recordCaseLabel;
	}

	public void SwitchStmt.setRecordCaseLabel(String label) {
		this.recordCaseLabel = label;
	}

	MethodAccess contributes each typestateSwitchProblem() to SwitchStmt.collectTypestateProblems(); 
	syn Collection<Problem> MethodAccess.typestateSwitchProblem() {
		LinkedList<Problem> problems = new LinkedList<Problem>();
		if(!isChecked() && hasPrevExpr()) {
			Expr va = prevExpr();
			if (va.hasTypestateState() && !va.hasState()) { // if va does not have state, report error
				problems.add(error("No Init State found in VarAccess " + va));
				return problems;
			}
			if (va.hasTypestateState() && va.hasState()) {
				MethodDecl md = this.decl();
				HashMap<String, State> stateMap = va.getState();
				// Only handle va in typestateswitch here
				if (stateMap.size() > 1) {
					SwitchStmt switchStmt = lookupSwitch();                	                	
					if (switchStmt == null) { // already handled 
						return new LinkedList<Problem>();
					}

					HashMap<Stmt, StmtInfo> infoMap = switchStmt.getStmtInfoMap();
					// Lookup information of the Stmt which contains this MethodAccess, if not found report error
					StmtInfo info = this.lookupInfo(infoMap);
					if (info == null) {
						problems.add(error("MethodAccess " + this + " in SwitchStmt does not have valid case label."));
						return problems;
					}
					// Lookup case label, if the TypestateSwitch does not contains the label, report error.
					String caseLabel = info.getCaseLabel();                      
					if (!stateMap.containsKey(caseLabel)) {
						problems.add(error("TypestateSwitch does not contains label " + caseLabel));
						return problems;
					}
					// Report method in a case without termination problem
					if (!info.hasTermination()) { 
						problems.add(error("MethodAccess: " + this + " is in an case without break or continue."));
						return problems;
					}
					State currState;
					if (switchStmt.getRecordCaseLabel() == null) {
						switchStmt.setRecordCaseLabel(caseLabel);
						currState = stateMap.get(caseLabel);
					} else {
						if (switchStmt.getRecordCaseLabel().equals(caseLabel)) {
							// in same case, restore previous state for typestate checking
							currState = getSingleStateFromMap(switchStmt.getRecordState()); // if in switch?
						} else {
							switchStmt.setRecordCaseLabel(caseLabel);
							currState = stateMap.get(caseLabel);
						}
					}					
					// Typestate checking and state updating
					problems = collectProblems(currState, md, va);					
					if (problems.size() != 0) {
						return problems;
					}
					// Reset and record state
					switchStmt.setRecordState(va.getState()); // record current state
					va.setState(stateMap); // reset state for next check				
                }				
			}			
		}
		return problems;		
	}

	ConstCase contributes each typestateSwitchProblem() to SwitchStmt.collectTypestateProblems();
	syn Collection<Problem> ConstCase.typestateSwitchProblem() {
		LinkedList<Problem> problems = new LinkedList<Problem>();
		SwitchStmt switchStmt = lookupSwitch();
		HashMap<Stmt, StmtInfo> infoMap = switchStmt.getStmtInfoMap();
		StmtInfo info = infoMap.get(this);
		if (!info.hasTermination()) {
			problems.add(error("Case with label: " + getValue() + " in Typestate switch has no break or continue statement."));
			return problems;
		}
		return problems;
	}
}