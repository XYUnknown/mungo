aspect SwitchCaseAnalysis {
	/**
	 * A map recording variable-state pairs in each valid case
	 */
	private HashMap<String, HashMap<Variable, HashMap<String, State>>> SwitchStmt.stateMap;
	public HashMap<String, HashMap<Variable, HashMap<String, State>>> SwitchStmt.getStateMap() {
		return this.stateMap;
	}
	public void SwitchStmt.initStateMap() {
		this.stateMap = new HashMap<String, HashMap<Variable, HashMap<String, State>>>();
		Block blk = this.getBlock();
		for (Stmt s: blk.getStmts()) {
			if (s instanceof ConstCase) {
				Expr exp = ((ConstCase)s).getValue();
				if (exp.type().isEnumDeclType()){
					VarAccess value = (VarAccess)((ConstCase)s).getValue();
					String caseLabel = value.getID();
					HashMap<Variable, HashMap<String, State>> varState = new HashMap<Variable, HashMap<String, State>>();
					HashMap<String, State> initState = new HashMap<String, State>();
					initState.put(this.recordSwitchState.get(caseLabel).getID(), this.recordSwitchState.get(caseLabel));
					varState.put(this.recordVariable, initState); // initialise state according to caseLabel
					this.stateMap.put(caseLabel, varState);
				}
			}
		}
	}

	public void SwitchStmt.updateRecordState(String label, Variable v, HashMap<String, State> state) {
		if (this.stateMap.containsKey(label)) {
			this.stateMap.get(label).put(v, state);
		}
	}

	public boolean SwitchStmt.isEndCaseSameState() {
		HashMap<Variable, HashMap<String, State>> checkMap = new HashMap<Variable, HashMap<String, State>>();
		for (String caseLabel: this.stateMap.keySet()) {
			HashMap<Variable, HashMap<String, State>> map = this.stateMap.get(caseLabel);
			for (Variable v: this.varList){
				if (!map.containsKey(v)) {
					return false;
				} else {
					if (!checkMap.containsKey(v)) {
						checkMap.put(v, map.get(v));
					} else {
						if(!checkMap.get(v).equals(map.get(v))){
							return false;
						}
					}
				}
			}
		}
		return true;
	}

	/**
	 * A list record all Variables in the SwitchStmt
	 */
	private LinkedList<Variable> SwitchStmt.varList;

	public LinkedList<Variable> SwitchStmt.getVarList() {
		return this.varList;
	} 

	public void SwitchStmt.addVariable(Variable v) {
		if (this.varList == null) {
			this.varList = new LinkedList<Variable>();
		}
		if (!this.varList.contains(v)) {
			this.varList.add(v);
		}		
	}

	/**
	 * A map recording statement information
	 */
	private HashMap<Stmt, StmtInfo> SwitchStmt.stmtInfoMap;

	/**
	 * Record the initial switch states of the variable in Expr
	 */
	private HashMap<String, State> SwitchStmt.recordSwitchState;

	public HashMap<String, State> SwitchStmt.getRecordTypestateSwitch() {
		return this.recordSwitchState;
	}

	public void SwitchStmt.setRecordTypestateSwitch(HashMap<String, State> switchState) {
		this.recordSwitchState = switchState;
	}

	/**
	 * Record Variable, the variable in Expr of the SwitchStmt
	 * which the state will be tracked.
	 */
	private Variable SwitchStmt.recordVariable;

	public Variable SwitchStmt.getRecordVariable() {
		return this.recordVariable;
	}

	public void SwitchStmt.setRecordVariable(Variable variable) {
		this.recordVariable = variable;
	}

	/**
	 * Set record variable according to Expr
	 */
	public void SwitchStmt.initRecordVariable() {
		Expr expr = getExpr();
		if (expr instanceof Dot) {
			Dot d = (Dot) expr;
			if (d.lastAccess() instanceof MethodAccess) {
				Expr preExpr = ((MethodAccess)d.lastAccess()).prevExpr();
				if (preExpr instanceof VarAccess) { // this?
					setRecordVariable(((VarAccess)preExpr).decl());
				}
			}
		}
	}

	class StmtInfo {
		private String caseLabel;
		private int termination = -1; // -1 no termination, 0 break/end block, 1 continue
		private String terminationLabel = null;
		private boolean isLast = false;
		public StmtInfo(String caseLabel) {
			this.caseLabel = caseLabel;
		}

		public void setTermination(int termination) {
			if ((-1 <= termination) && (1 >= termination)) {
				this.termination = termination;
			}
		}

		public void setTerminationLabel(String terminationLabel) {
			this.terminationLabel = terminationLabel;
		}

		public String getCaseLabel() {
			return this.caseLabel;
		}

		public int getTermination() {
			return this.termination;
		}

		public String getTerminationLabel() {
			return this.terminationLabel;
		}

		public boolean hasTermination() {
			return this.termination != -1;
		}

		public boolean hasBreak() {
			return this.termination == 0;
		}

		public boolean hasContinue() {
			return this.termination == 1;
		}

		public boolean isLastStmt() {
			return this.isLast;
		}

		public void setLastStmt(boolean isLast) {
			this.isLast = isLast;
		}
	}

	public HashMap<Stmt, StmtInfo> SwitchStmt.getStmtInfoMap() {
		if (this.stmtInfoMap != null) {
			return stmtInfoMap;
		}
		Stack<Stmt> stack = new Stack<Stmt>();
		HashMap<Stmt, StmtInfo> map = new HashMap<Stmt, StmtInfo>();
		Block blk = getBlock();
		String caseLabel = null;
		boolean valid = false;
		for (Stmt s: blk.getStmts()) {			
			if (s instanceof Case) {
				if (s instanceof ConstCase) {
					Expr exp = ((ConstCase)s).getValue();
					if (exp.type().isEnumDeclType()){
						VarAccess value = (VarAccess)((ConstCase)s).getValue();
						caseLabel = value.getID();
						valid = true;
					} else {
						caseLabel = ((ConstCase)s).getValue().toString(); // Store information including invalid case label
					}					
				} else {
					caseLabel = "";
				}
				StmtInfo info = new StmtInfo(caseLabel);
				s.setDereferenced(true); // initially dereference set true, when break/continue found, might be set false
				map.put(s, info);

				if (stack.empty()) {
					stack.push(s);
				} else {
					stack.clear();
					stack.push(s);
				}
			} else if (s instanceof BreakStmt) {
				if (caseLabel != null) {
					String label = ((BreakStmt)s).hasLabel() ? null : ((BreakStmt)s).getLabel();
					StmtInfo info = new StmtInfo(caseLabel);
					info.setTermination(0);
					info.setTerminationLabel(label);
					s.setDereferenced(!valid); // if not valid, dereference stmt
					map.put(s, info);
					caseLabel = null; // reset case label

					Stmt temp = null;
					while(!stack.empty()) {
						temp = stack.pop();
						StmtInfo i = map.get(temp);
						i.setTermination(0);
						i.setTerminationLabel(label);
						temp.setDereferenced(!valid);
						if (temp instanceof Case) {
							break;
						}
					}
				}
				valid = false; // reset stmt valid indication				
			} else if (s instanceof ContinueStmt) {
				if (caseLabel != null) {
					String label = ((ContinueStmt)s).hasLabel() ? null : ((ContinueStmt)s).getLabel();
					StmtInfo info = new StmtInfo(caseLabel);
					info.setTermination(1);
					info.setTerminationLabel(label);
					s.setDereferenced(!valid); // if not valid, dereference stmt
					map.put(s, info);
					caseLabel = null; // reset case label

					Stmt temp = null;
					while(!stack.empty()) {
						temp = stack.pop();
						StmtInfo i = map.get(temp);
						i.setTermination(1);
						i.setTerminationLabel(label);
						temp.setDereferenced(!valid);
						if (temp instanceof Case) {
							break;
						}
					}
				}
				valid = false; // reset stmt valid indication				
			} else {
				if (caseLabel != null) {
					StmtInfo info = new StmtInfo(caseLabel);
					map.put(s, info);
					stack.push(s);
				}
			}
		}
		this.stmtInfoMap = map;
		labelLastTermination(); // last break / continue is labelled here
		return map;
	}

	private void SwitchStmt.labelLastTermination() {
		Block blk = getBlock();
		LinkedList<Stmt> list = new LinkedList<Stmt>();
		for (Stmt s: blk.getStmts()) {
			if ((s instanceof BreakStmt) || (s instanceof ContinueStmt)) {
				if (!s.isDereferenced()) {
					list.add(s);
				}
			}
		}
		Stmt st = list.getLast();
		this.stmtInfoMap.get(st).setLastStmt(true);
	}

	public StmtInfo MethodAccess.lookupInfo(HashMap<Stmt, StmtInfo> infoMap) {
		ASTNode node = this.getParent();
        while (node != null) {
            if (node instanceof Stmt) {
                if (infoMap.containsKey((Stmt)node)) {
                	return infoMap.get((Stmt)node);
                } else {
                	node = node.getParent();
                }
            } else {
                node = node.getParent();
            }
        }
        return null;
	}

	/**
     * Lookup the host SwitchStmt of the a MethodAccess
     */
    syn SwitchStmt MethodAccess.lookupSwitch() {
    	if (hasPrevExpr()) {
    		Expr va = prevExpr();
    		Variable v;
    		if (!va.isVariable()) {
    			return null;
    		} else {
    			v = ((VarAccess) va).decl();
    		}
    		ASTNode node = this.getParent();
        	while (node != null) {
            	if (node instanceof SwitchStmt) {
            		if (v.equals(((SwitchStmt) node).getRecordVariable())) {
            			return (SwitchStmt) node;
            		} else {
            			node = node.getParent();
            		}                	
            	} else {
                	node = node.getParent();
            	}
        	}
        	return null;
    	}        
        return null;
    }

    /**
     * Lookup all Switch Stmt of the a MethodAccess
     */
	syn LinkedList<SwitchStmt> MethodAccess.lookupAllSwitch() {
		LinkedList<SwitchStmt> list = new LinkedList<SwitchStmt>();
		ASTNode node = this.getParent();
		while (node != null) {
			if (node instanceof SwitchStmt) {
				list.add((SwitchStmt) node);               	
			}
			node = node.getParent();
		}
		return list;
	}

    /**
     * Check if a MethodAccess is the Expr of a SwitchStmt or not
     */
    syn boolean MethodAccess.isSwitchStmtExpr() {
    	return (lookupExprSwitchStmt() != null);
    }

    syn SwitchStmt MethodAccess.lookupExprSwitchStmt() {
    	if (hasPrevExpr()) {
    		Expr va = prevExpr();
    		Variable v;
    		if (!va.isVariable()) {
    			return null;
    		} else {
    			v = ((VarAccess) va).decl();
    		}
    		ASTNode node = this.getParent();
        	while (node != null) {
            	if (node instanceof SwitchStmt) {
            		if (v.equals(((SwitchStmt) node).getRecordVariable())) { // switch stmt match and variable match
            			return (SwitchStmt) node;
            		} else {
            			node = node.getParent();
            		}                	
            	} else if (node instanceof Block) { //not in expr
            		return null;
            	} else {
                	node = node.getParent();
            	}
        	}
        	return null;
    	}        
        return null;
    }

    /**
     * Lookup a Switch Stmt of the a Stmt
     */
    syn SwitchStmt Stmt.lookupSwitch() {
        ASTNode node = this.getParent();
        while (node != null) {
            if (node instanceof SwitchStmt) {
                return (SwitchStmt) node;
            } else {
                node = node.getParent();
            }
        }
        return null;
    }

    /**
     * Collect all MethodAccess in a SwitchStmt
     */
    coll LinkedList<MethodAccess> SwitchStmt.collectMethodAccess() root SwitchStmt;
	ConstructorDecl contributes {
		if (checkImplicitConstructorInvocation()) {
			getImplicitConstructorInvocation().collectContributions();
		}
		super.collectContributions();
	} to SwitchStmt.collectMethodAccess();

	MethodAccess contributes each selfReport() to SwitchStmt.collectMethodAccess();
	syn LinkedList<MethodAccess> MethodAccess.selfReport() {
		LinkedList<MethodAccess> list = new LinkedList<MethodAccess>();
		SwitchStmt hostSwitchStmt = lookupSwitch();
		list.add(this);				
		return list;
	}
}