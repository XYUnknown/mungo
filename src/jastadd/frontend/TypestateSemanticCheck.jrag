aspect TypestateSemanticCheck {
	/**
     * Processes from-source compilation units by error-checking them.
     * This method only report semantic errors and warnings.
     *
     * @return zero on success, non-zero on error
     */
    protected int Frontend.processCompilationUnitForTypestate(CompilationUnit unit) throws Error {
    	System.out.println("start");
		if (unit != null) {
			try {
				System.out.println("processing...");
				Collection<Problem> errors = unit.parseErrors();
				Collection<Problem> warnings = EMPTY_PROBLEM_LIST;
				if (errors.isEmpty()|| program.options().hasOption("-recover")) {
					long start = System.nanoTime();
					errors = unit.terrors();
					warnings = unit.twarnings();
					program.errorCheckTime += System.nanoTime() - start;
				} 
				if (!errors.isEmpty()) {
					return EXIT_ERROR;
				} else {
            		if (!warnings.isEmpty() && !program.options().hasOption("-nowarn")) {
              			processWarnings(warnings, unit);
            		}
         		}

			} catch (Error e) {
				System.err.println("Encountered error while processing " + unit.pathName());
				throw e;
			}
		}
		return EXIT_SUCCESS;
    }



    /**
     * Collect sematic problems of typestate protocol file
     */
    coll LinkedList<Problem> CompilationUnit.tproblems() root CompilationUnit;

    syn Collection<Problem> CompilationUnit.terrors() {
		Collection<Problem> errors = new LinkedList<Problem>();
		/*
		for (Problem problem : tproblems()) {
			if (problem.severity() == Problem.Severity.ERROR) {
				errors.add(problem);
			}
    	}
    	*/
		return errors;
	}

	syn Collection<Problem> CompilationUnit.twarnings() {
		Collection<Problem> warnings = new LinkedList<Problem>();
		/*
		for (Problem problem : tproblems()) {
			if (problem.severity() == Problem.Severity.WARNING) {
				warnings.add(problem);
			}
		}
		*/
		return warnings;
	}

    // Add problem contributions from the implicit constructor invocation NTA.
    ConstructorDecl contributes {
        if (checkImplicitConstructorInvocation()) {
            getImplicitConstructorInvocation().collectContributions();
        }
        super.collectContributions();
    } to CompilationUnit.tproblems();


    CompilationUnit contributes each typestateSemanticProblems() to CompilationUnit.tproblems();
	syn Collection<Problem> CompilationUnit.typestateSemanticProblems() {
		Collection<Problem> problems = new LinkedList<Problem>();
		System.out.println("CompilationUnit contributing to tproblems()");
		return problems;
	}

    //State contributes each typestateSemanticProblems() to CompilationUnit.tproblems();
    //syn Collection<Problem> State.typestateSemanticProblems() {
    	//LinkedList<Problem> problems = new LinkedList<Problem>();
    	//if(isDuplicate()){
			//problems.add(error("Duplicate State: " + getID() + "."));
    	//}
		//if(!isReachable()){
			//problems.add(warning("State not reachable: " + getID() + "."));
		//}

		//String path;
		//if((path = getCircularPath()) != null){
			//problems.add(warning("Circular-referenced state definition: " + path + "."));
		//}
		//return problems;
    //}
    // TODO add all typestateSemanticProblems()

	//TypestateLabel contributes each typestateSemanticProblems() to CompilationUnit.tproblems();
    //syn Collection<Problem> TypestateLabel.typestateSemanticProblems() {
    	//LinkedList problems = new LinkedList<Problem>();
    	//if(getTarget() == null){
			//problems.add(error("No Definition for state: " + getLabel()));
    	//}
    	//return problems;
    //}

    // Debug
    public void ASTNode.doPrintFullTraversal() {
    	System.out.println(this);
		for (int i = 0; i < getNumChild(); i++) {
			getChild(i).doPrintFullTraversal();
		}
	}
}